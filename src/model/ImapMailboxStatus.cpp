/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/ImapMailboxStatus.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



ImapMailboxStatus::ImapMailboxStatus()
{
    m_Name = utility::conversions::to_string_t("");
    m_NameIsSet = false;
    m_ReadOnly = false;
    m_ReadOnlyIsSet = false;
    m_ItemsIsSet = false;
    m_FlagsIsSet = false;
    m_PermanentFlagsIsSet = false;
    m_UnseenSeqNum = 0L;
    m_UnseenSeqNumIsSet = false;
    m_Messages = 0;
    m_MessagesIsSet = false;
    m_Recent = 0;
    m_RecentIsSet = false;
    m_Unseen = 0;
    m_UnseenIsSet = false;
    m_UidNext = 0L;
    m_UidNextIsSet = false;
    m_UidValidity = 0;
    m_UidValidityIsSet = false;
    m_AppendLimit = 0;
    m_AppendLimitIsSet = false;
}

ImapMailboxStatus::~ImapMailboxStatus()
{
}

void ImapMailboxStatus::validate()
{
    // TODO: implement validation
}

web::json::value ImapMailboxStatus::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_NameIsSet)
    {
        val[utility::conversions::to_string_t(U("name"))] = ModelBase::toJson(m_Name);
    }
    if(m_ReadOnlyIsSet)
    {
        val[utility::conversions::to_string_t(U("readOnly"))] = ModelBase::toJson(m_ReadOnly);
    }
    if(m_ItemsIsSet)
    {
        val[utility::conversions::to_string_t(U("items"))] = ModelBase::toJson(m_Items);
    }
    if(m_FlagsIsSet)
    {
        val[utility::conversions::to_string_t(U("flags"))] = ModelBase::toJson(m_Flags);
    }
    if(m_PermanentFlagsIsSet)
    {
        val[utility::conversions::to_string_t(U("permanentFlags"))] = ModelBase::toJson(m_PermanentFlags);
    }
    if(m_UnseenSeqNumIsSet)
    {
        val[utility::conversions::to_string_t(U("unseenSeqNum"))] = ModelBase::toJson(m_UnseenSeqNum);
    }
    if(m_MessagesIsSet)
    {
        val[utility::conversions::to_string_t(U("messages"))] = ModelBase::toJson(m_Messages);
    }
    if(m_RecentIsSet)
    {
        val[utility::conversions::to_string_t(U("recent"))] = ModelBase::toJson(m_Recent);
    }
    if(m_UnseenIsSet)
    {
        val[utility::conversions::to_string_t(U("unseen"))] = ModelBase::toJson(m_Unseen);
    }
    if(m_UidNextIsSet)
    {
        val[utility::conversions::to_string_t(U("uidNext"))] = ModelBase::toJson(m_UidNext);
    }
    if(m_UidValidityIsSet)
    {
        val[utility::conversions::to_string_t(U("uidValidity"))] = ModelBase::toJson(m_UidValidity);
    }
    if(m_AppendLimitIsSet)
    {
        val[utility::conversions::to_string_t(U("appendLimit"))] = ModelBase::toJson(m_AppendLimit);
    }

    return val;
}

bool ImapMailboxStatus::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("name"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("name")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setName;
            ok &= ModelBase::fromJson(fieldValue, refVal_setName);
            setName(refVal_setName);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("readOnly"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("readOnly")));
        if(!fieldValue.is_null())
        {
            bool refVal_setReadOnly;
            ok &= ModelBase::fromJson(fieldValue, refVal_setReadOnly);
            setReadOnly(refVal_setReadOnly);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("items"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("items")));
        if(!fieldValue.is_null())
        {
            std::map<utility::string_t, std::shared_ptr<Object>> refVal_setItems;
            ok &= ModelBase::fromJson(fieldValue, refVal_setItems);
            setItems(refVal_setItems);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("flags"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("flags")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setFlags;
            ok &= ModelBase::fromJson(fieldValue, refVal_setFlags);
            setFlags(refVal_setFlags);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("permanentFlags"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("permanentFlags")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setPermanentFlags;
            ok &= ModelBase::fromJson(fieldValue, refVal_setPermanentFlags);
            setPermanentFlags(refVal_setPermanentFlags);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("unseenSeqNum"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("unseenSeqNum")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setUnseenSeqNum;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUnseenSeqNum);
            setUnseenSeqNum(refVal_setUnseenSeqNum);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("messages"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("messages")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setMessages;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMessages);
            setMessages(refVal_setMessages);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("recent"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("recent")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setRecent;
            ok &= ModelBase::fromJson(fieldValue, refVal_setRecent);
            setRecent(refVal_setRecent);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("unseen"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("unseen")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setUnseen;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUnseen);
            setUnseen(refVal_setUnseen);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("uidNext"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("uidNext")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setUidNext;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUidNext);
            setUidNext(refVal_setUidNext);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("uidValidity"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("uidValidity")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setUidValidity;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUidValidity);
            setUidValidity(refVal_setUidValidity);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("appendLimit"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("appendLimit")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setAppendLimit;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAppendLimit);
            setAppendLimit(refVal_setAppendLimit);
        }
    }
    return ok;
}

void ImapMailboxStatus::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_NameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("name")), m_Name));
    }
    if(m_ReadOnlyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("readOnly")), m_ReadOnly));
    }
    if(m_ItemsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("items")), m_Items));
    }
    if(m_FlagsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("flags")), m_Flags));
    }
    if(m_PermanentFlagsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("permanentFlags")), m_PermanentFlags));
    }
    if(m_UnseenSeqNumIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("unseenSeqNum")), m_UnseenSeqNum));
    }
    if(m_MessagesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("messages")), m_Messages));
    }
    if(m_RecentIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("recent")), m_Recent));
    }
    if(m_UnseenIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("unseen")), m_Unseen));
    }
    if(m_UidNextIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("uidNext")), m_UidNext));
    }
    if(m_UidValidityIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("uidValidity")), m_UidValidity));
    }
    if(m_AppendLimitIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("appendLimit")), m_AppendLimit));
    }
}

bool ImapMailboxStatus::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("name"))))
    {
        utility::string_t refVal_setName;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("name"))), refVal_setName );
        setName(refVal_setName);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("readOnly"))))
    {
        bool refVal_setReadOnly;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("readOnly"))), refVal_setReadOnly );
        setReadOnly(refVal_setReadOnly);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("items"))))
    {
        std::map<utility::string_t, std::shared_ptr<Object>> refVal_setItems;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("items"))), refVal_setItems );
        setItems(refVal_setItems);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("flags"))))
    {
        std::vector<utility::string_t> refVal_setFlags;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("flags"))), refVal_setFlags );
        setFlags(refVal_setFlags);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("permanentFlags"))))
    {
        std::vector<utility::string_t> refVal_setPermanentFlags;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("permanentFlags"))), refVal_setPermanentFlags );
        setPermanentFlags(refVal_setPermanentFlags);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("unseenSeqNum"))))
    {
        int64_t refVal_setUnseenSeqNum;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("unseenSeqNum"))), refVal_setUnseenSeqNum );
        setUnseenSeqNum(refVal_setUnseenSeqNum);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("messages"))))
    {
        int32_t refVal_setMessages;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("messages"))), refVal_setMessages );
        setMessages(refVal_setMessages);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("recent"))))
    {
        int32_t refVal_setRecent;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("recent"))), refVal_setRecent );
        setRecent(refVal_setRecent);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("unseen"))))
    {
        int32_t refVal_setUnseen;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("unseen"))), refVal_setUnseen );
        setUnseen(refVal_setUnseen);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("uidNext"))))
    {
        int64_t refVal_setUidNext;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("uidNext"))), refVal_setUidNext );
        setUidNext(refVal_setUidNext);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("uidValidity"))))
    {
        int32_t refVal_setUidValidity;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("uidValidity"))), refVal_setUidValidity );
        setUidValidity(refVal_setUidValidity);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("appendLimit"))))
    {
        int32_t refVal_setAppendLimit;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("appendLimit"))), refVal_setAppendLimit );
        setAppendLimit(refVal_setAppendLimit);
    }
    return ok;
}

utility::string_t ImapMailboxStatus::getName() const
{
    return m_Name;
}

void ImapMailboxStatus::setName(const utility::string_t& value)
{
    m_Name = value;
    m_NameIsSet = true;
}

bool ImapMailboxStatus::nameIsSet() const
{
    return m_NameIsSet;
}

void ImapMailboxStatus::unsetName()
{
    m_NameIsSet = false;
}
bool ImapMailboxStatus::isReadOnly() const
{
    return m_ReadOnly;
}

void ImapMailboxStatus::setReadOnly(bool value)
{
    m_ReadOnly = value;
    m_ReadOnlyIsSet = true;
}

bool ImapMailboxStatus::readOnlyIsSet() const
{
    return m_ReadOnlyIsSet;
}

void ImapMailboxStatus::unsetReadOnly()
{
    m_ReadOnlyIsSet = false;
}
std::map<utility::string_t, std::shared_ptr<Object>>& ImapMailboxStatus::getItems()
{
    return m_Items;
}

void ImapMailboxStatus::setItems(const std::map<utility::string_t, std::shared_ptr<Object>>& value)
{
    m_Items = value;
    m_ItemsIsSet = true;
}

bool ImapMailboxStatus::itemsIsSet() const
{
    return m_ItemsIsSet;
}

void ImapMailboxStatus::unsetItems()
{
    m_ItemsIsSet = false;
}
std::vector<utility::string_t>& ImapMailboxStatus::getFlags()
{
    return m_Flags;
}

void ImapMailboxStatus::setFlags(const std::vector<utility::string_t>& value)
{
    m_Flags = value;
    m_FlagsIsSet = true;
}

bool ImapMailboxStatus::flagsIsSet() const
{
    return m_FlagsIsSet;
}

void ImapMailboxStatus::unsetFlags()
{
    m_FlagsIsSet = false;
}
std::vector<utility::string_t>& ImapMailboxStatus::getPermanentFlags()
{
    return m_PermanentFlags;
}

void ImapMailboxStatus::setPermanentFlags(const std::vector<utility::string_t>& value)
{
    m_PermanentFlags = value;
    m_PermanentFlagsIsSet = true;
}

bool ImapMailboxStatus::permanentFlagsIsSet() const
{
    return m_PermanentFlagsIsSet;
}

void ImapMailboxStatus::unsetPermanentFlags()
{
    m_PermanentFlagsIsSet = false;
}
int64_t ImapMailboxStatus::getUnseenSeqNum() const
{
    return m_UnseenSeqNum;
}

void ImapMailboxStatus::setUnseenSeqNum(int64_t value)
{
    m_UnseenSeqNum = value;
    m_UnseenSeqNumIsSet = true;
}

bool ImapMailboxStatus::unseenSeqNumIsSet() const
{
    return m_UnseenSeqNumIsSet;
}

void ImapMailboxStatus::unsetUnseenSeqNum()
{
    m_UnseenSeqNumIsSet = false;
}
int32_t ImapMailboxStatus::getMessages() const
{
    return m_Messages;
}

void ImapMailboxStatus::setMessages(int32_t value)
{
    m_Messages = value;
    m_MessagesIsSet = true;
}

bool ImapMailboxStatus::messagesIsSet() const
{
    return m_MessagesIsSet;
}

void ImapMailboxStatus::unsetMessages()
{
    m_MessagesIsSet = false;
}
int32_t ImapMailboxStatus::getRecent() const
{
    return m_Recent;
}

void ImapMailboxStatus::setRecent(int32_t value)
{
    m_Recent = value;
    m_RecentIsSet = true;
}

bool ImapMailboxStatus::recentIsSet() const
{
    return m_RecentIsSet;
}

void ImapMailboxStatus::unsetRecent()
{
    m_RecentIsSet = false;
}
int32_t ImapMailboxStatus::getUnseen() const
{
    return m_Unseen;
}

void ImapMailboxStatus::setUnseen(int32_t value)
{
    m_Unseen = value;
    m_UnseenIsSet = true;
}

bool ImapMailboxStatus::unseenIsSet() const
{
    return m_UnseenIsSet;
}

void ImapMailboxStatus::unsetUnseen()
{
    m_UnseenIsSet = false;
}
int64_t ImapMailboxStatus::getUidNext() const
{
    return m_UidNext;
}

void ImapMailboxStatus::setUidNext(int64_t value)
{
    m_UidNext = value;
    m_UidNextIsSet = true;
}

bool ImapMailboxStatus::uidNextIsSet() const
{
    return m_UidNextIsSet;
}

void ImapMailboxStatus::unsetUidNext()
{
    m_UidNextIsSet = false;
}
int32_t ImapMailboxStatus::getUidValidity() const
{
    return m_UidValidity;
}

void ImapMailboxStatus::setUidValidity(int32_t value)
{
    m_UidValidity = value;
    m_UidValidityIsSet = true;
}

bool ImapMailboxStatus::uidValidityIsSet() const
{
    return m_UidValidityIsSet;
}

void ImapMailboxStatus::unsetUidValidity()
{
    m_UidValidityIsSet = false;
}
int32_t ImapMailboxStatus::getAppendLimit() const
{
    return m_AppendLimit;
}

void ImapMailboxStatus::setAppendLimit(int32_t value)
{
    m_AppendLimit = value;
    m_AppendLimitIsSet = true;
}

bool ImapMailboxStatus::appendLimitIsSet() const
{
    return m_AppendLimitIsSet;
}

void ImapMailboxStatus::unsetAppendLimit()
{
    m_AppendLimitIsSet = false;
}
}
}
}
}


