/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/WaitForSingleSmsOptions.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



WaitForSingleSmsOptions::WaitForSingleSmsOptions()
{
    m_PhoneNumberId = utility::conversions::to_string_t("");
    m_PhoneNumberIdIsSet = false;
    m_Timeout = 0L;
    m_TimeoutIsSet = false;
    m_UnreadOnly = false;
    m_UnreadOnlyIsSet = false;
    m_Before = utility::datetime();
    m_BeforeIsSet = false;
    m_Since = utility::datetime();
    m_SinceIsSet = false;
    m_SortDirection = utility::conversions::to_string_t("");
    m_SortDirectionIsSet = false;
    m_Delay = 0L;
    m_DelayIsSet = false;
}

WaitForSingleSmsOptions::~WaitForSingleSmsOptions()
{
}

void WaitForSingleSmsOptions::validate()
{
    // TODO: implement validation
}

web::json::value WaitForSingleSmsOptions::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_PhoneNumberIdIsSet)
    {
        val[utility::conversions::to_string_t(U("phoneNumberId"))] = ModelBase::toJson(m_PhoneNumberId);
    }
    if(m_TimeoutIsSet)
    {
        val[utility::conversions::to_string_t(U("timeout"))] = ModelBase::toJson(m_Timeout);
    }
    if(m_UnreadOnlyIsSet)
    {
        val[utility::conversions::to_string_t(U("unreadOnly"))] = ModelBase::toJson(m_UnreadOnly);
    }
    if(m_BeforeIsSet)
    {
        val[utility::conversions::to_string_t(U("before"))] = ModelBase::toJson(m_Before);
    }
    if(m_SinceIsSet)
    {
        val[utility::conversions::to_string_t(U("since"))] = ModelBase::toJson(m_Since);
    }
    if(m_SortDirectionIsSet)
    {
        val[utility::conversions::to_string_t(U("sortDirection"))] = ModelBase::toJson(m_SortDirection);
    }
    if(m_DelayIsSet)
    {
        val[utility::conversions::to_string_t(U("delay"))] = ModelBase::toJson(m_Delay);
    }

    return val;
}

bool WaitForSingleSmsOptions::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("phoneNumberId"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("phoneNumberId")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setPhoneNumberId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setPhoneNumberId);
            setPhoneNumberId(refVal_setPhoneNumberId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("timeout"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("timeout")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setTimeout;
            ok &= ModelBase::fromJson(fieldValue, refVal_setTimeout);
            setTimeout(refVal_setTimeout);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("unreadOnly"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("unreadOnly")));
        if(!fieldValue.is_null())
        {
            bool refVal_setUnreadOnly;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUnreadOnly);
            setUnreadOnly(refVal_setUnreadOnly);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("before"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("before")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setBefore;
            ok &= ModelBase::fromJson(fieldValue, refVal_setBefore);
            setBefore(refVal_setBefore);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("since"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("since")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setSince;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSince);
            setSince(refVal_setSince);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("sortDirection"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("sortDirection")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setSortDirection;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSortDirection);
            setSortDirection(refVal_setSortDirection);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("delay"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("delay")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setDelay;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDelay);
            setDelay(refVal_setDelay);
        }
    }
    return ok;
}

void WaitForSingleSmsOptions::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_PhoneNumberIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("phoneNumberId")), m_PhoneNumberId));
    }
    if(m_TimeoutIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("timeout")), m_Timeout));
    }
    if(m_UnreadOnlyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("unreadOnly")), m_UnreadOnly));
    }
    if(m_BeforeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("before")), m_Before));
    }
    if(m_SinceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("since")), m_Since));
    }
    if(m_SortDirectionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("sortDirection")), m_SortDirection));
    }
    if(m_DelayIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("delay")), m_Delay));
    }
}

bool WaitForSingleSmsOptions::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("phoneNumberId"))))
    {
        utility::string_t refVal_setPhoneNumberId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("phoneNumberId"))), refVal_setPhoneNumberId );
        setPhoneNumberId(refVal_setPhoneNumberId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("timeout"))))
    {
        int64_t refVal_setTimeout;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("timeout"))), refVal_setTimeout );
        setTimeout(refVal_setTimeout);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("unreadOnly"))))
    {
        bool refVal_setUnreadOnly;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("unreadOnly"))), refVal_setUnreadOnly );
        setUnreadOnly(refVal_setUnreadOnly);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("before"))))
    {
        utility::datetime refVal_setBefore;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("before"))), refVal_setBefore );
        setBefore(refVal_setBefore);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("since"))))
    {
        utility::datetime refVal_setSince;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("since"))), refVal_setSince );
        setSince(refVal_setSince);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("sortDirection"))))
    {
        utility::string_t refVal_setSortDirection;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("sortDirection"))), refVal_setSortDirection );
        setSortDirection(refVal_setSortDirection);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("delay"))))
    {
        int64_t refVal_setDelay;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("delay"))), refVal_setDelay );
        setDelay(refVal_setDelay);
    }
    return ok;
}

utility::string_t WaitForSingleSmsOptions::getPhoneNumberId() const
{
    return m_PhoneNumberId;
}

void WaitForSingleSmsOptions::setPhoneNumberId(const utility::string_t& value)
{
    m_PhoneNumberId = value;
    m_PhoneNumberIdIsSet = true;
}

bool WaitForSingleSmsOptions::phoneNumberIdIsSet() const
{
    return m_PhoneNumberIdIsSet;
}

void WaitForSingleSmsOptions::unsetPhoneNumberId()
{
    m_PhoneNumberIdIsSet = false;
}
int64_t WaitForSingleSmsOptions::getTimeout() const
{
    return m_Timeout;
}

void WaitForSingleSmsOptions::setTimeout(int64_t value)
{
    m_Timeout = value;
    m_TimeoutIsSet = true;
}

bool WaitForSingleSmsOptions::timeoutIsSet() const
{
    return m_TimeoutIsSet;
}

void WaitForSingleSmsOptions::unsetTimeout()
{
    m_TimeoutIsSet = false;
}
bool WaitForSingleSmsOptions::isUnreadOnly() const
{
    return m_UnreadOnly;
}

void WaitForSingleSmsOptions::setUnreadOnly(bool value)
{
    m_UnreadOnly = value;
    m_UnreadOnlyIsSet = true;
}

bool WaitForSingleSmsOptions::unreadOnlyIsSet() const
{
    return m_UnreadOnlyIsSet;
}

void WaitForSingleSmsOptions::unsetUnreadOnly()
{
    m_UnreadOnlyIsSet = false;
}
utility::datetime WaitForSingleSmsOptions::getBefore() const
{
    return m_Before;
}

void WaitForSingleSmsOptions::setBefore(const utility::datetime& value)
{
    m_Before = value;
    m_BeforeIsSet = true;
}

bool WaitForSingleSmsOptions::beforeIsSet() const
{
    return m_BeforeIsSet;
}

void WaitForSingleSmsOptions::unsetBefore()
{
    m_BeforeIsSet = false;
}
utility::datetime WaitForSingleSmsOptions::getSince() const
{
    return m_Since;
}

void WaitForSingleSmsOptions::setSince(const utility::datetime& value)
{
    m_Since = value;
    m_SinceIsSet = true;
}

bool WaitForSingleSmsOptions::sinceIsSet() const
{
    return m_SinceIsSet;
}

void WaitForSingleSmsOptions::unsetSince()
{
    m_SinceIsSet = false;
}
utility::string_t WaitForSingleSmsOptions::getSortDirection() const
{
    return m_SortDirection;
}

void WaitForSingleSmsOptions::setSortDirection(const utility::string_t& value)
{
    m_SortDirection = value;
    m_SortDirectionIsSet = true;
}

bool WaitForSingleSmsOptions::sortDirectionIsSet() const
{
    return m_SortDirectionIsSet;
}

void WaitForSingleSmsOptions::unsetSortDirection()
{
    m_SortDirectionIsSet = false;
}
int64_t WaitForSingleSmsOptions::getDelay() const
{
    return m_Delay;
}

void WaitForSingleSmsOptions::setDelay(int64_t value)
{
    m_Delay = value;
    m_DelayIsSet = true;
}

bool WaitForSingleSmsOptions::delayIsSet() const
{
    return m_DelayIsSet;
}

void WaitForSingleSmsOptions::unsetDelay()
{
    m_DelayIsSet = false;
}
}
}
}
}


