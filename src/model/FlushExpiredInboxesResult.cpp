/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/FlushExpiredInboxesResult.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



FlushExpiredInboxesResult::FlushExpiredInboxesResult()
{
    m_InboxIdsIsSet = false;
    m_ExpireBefore = utility::datetime();
    m_ExpireBeforeIsSet = false;
}

FlushExpiredInboxesResult::~FlushExpiredInboxesResult()
{
}

void FlushExpiredInboxesResult::validate()
{
    // TODO: implement validation
}

web::json::value FlushExpiredInboxesResult::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_InboxIdsIsSet)
    {
        val[utility::conversions::to_string_t(U("inboxIds"))] = ModelBase::toJson(m_InboxIds);
    }
    if(m_ExpireBeforeIsSet)
    {
        val[utility::conversions::to_string_t(U("expireBefore"))] = ModelBase::toJson(m_ExpireBefore);
    }

    return val;
}

bool FlushExpiredInboxesResult::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("inboxIds"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("inboxIds")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setInboxIds;
            ok &= ModelBase::fromJson(fieldValue, refVal_setInboxIds);
            setInboxIds(refVal_setInboxIds);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("expireBefore"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("expireBefore")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setExpireBefore;
            ok &= ModelBase::fromJson(fieldValue, refVal_setExpireBefore);
            setExpireBefore(refVal_setExpireBefore);
        }
    }
    return ok;
}

void FlushExpiredInboxesResult::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_InboxIdsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("inboxIds")), m_InboxIds));
    }
    if(m_ExpireBeforeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("expireBefore")), m_ExpireBefore));
    }
}

bool FlushExpiredInboxesResult::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("inboxIds"))))
    {
        std::vector<utility::string_t> refVal_setInboxIds;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("inboxIds"))), refVal_setInboxIds );
        setInboxIds(refVal_setInboxIds);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("expireBefore"))))
    {
        utility::datetime refVal_setExpireBefore;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("expireBefore"))), refVal_setExpireBefore );
        setExpireBefore(refVal_setExpireBefore);
    }
    return ok;
}

std::vector<utility::string_t>& FlushExpiredInboxesResult::getInboxIds()
{
    return m_InboxIds;
}

void FlushExpiredInboxesResult::setInboxIds(const std::vector<utility::string_t>& value)
{
    m_InboxIds = value;
    m_InboxIdsIsSet = true;
}

bool FlushExpiredInboxesResult::inboxIdsIsSet() const
{
    return m_InboxIdsIsSet;
}

void FlushExpiredInboxesResult::unsetInboxIds()
{
    m_InboxIdsIsSet = false;
}
utility::datetime FlushExpiredInboxesResult::getExpireBefore() const
{
    return m_ExpireBefore;
}

void FlushExpiredInboxesResult::setExpireBefore(const utility::datetime& value)
{
    m_ExpireBefore = value;
    m_ExpireBeforeIsSet = true;
}

bool FlushExpiredInboxesResult::expireBeforeIsSet() const
{
    return m_ExpireBeforeIsSet;
}

void FlushExpiredInboxesResult::unsetExpireBefore()
{
    m_ExpireBeforeIsSet = false;
}
}
}
}
}


