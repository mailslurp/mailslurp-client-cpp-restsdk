/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/SortObject.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



SortObject::SortObject()
{
    m_Sorted = false;
    m_SortedIsSet = false;
    m_Unsorted = false;
    m_UnsortedIsSet = false;
    m_Empty = false;
    m_EmptyIsSet = false;
}

SortObject::~SortObject()
{
}

void SortObject::validate()
{
    // TODO: implement validation
}

web::json::value SortObject::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_SortedIsSet)
    {
        val[utility::conversions::to_string_t(U("sorted"))] = ModelBase::toJson(m_Sorted);
    }
    if(m_UnsortedIsSet)
    {
        val[utility::conversions::to_string_t(U("unsorted"))] = ModelBase::toJson(m_Unsorted);
    }
    if(m_EmptyIsSet)
    {
        val[utility::conversions::to_string_t(U("empty"))] = ModelBase::toJson(m_Empty);
    }

    return val;
}

bool SortObject::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("sorted"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("sorted")));
        if(!fieldValue.is_null())
        {
            bool refVal_setSorted;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSorted);
            setSorted(refVal_setSorted);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("unsorted"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("unsorted")));
        if(!fieldValue.is_null())
        {
            bool refVal_setUnsorted;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUnsorted);
            setUnsorted(refVal_setUnsorted);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("empty"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("empty")));
        if(!fieldValue.is_null())
        {
            bool refVal_setEmpty;
            ok &= ModelBase::fromJson(fieldValue, refVal_setEmpty);
            setEmpty(refVal_setEmpty);
        }
    }
    return ok;
}

void SortObject::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_SortedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("sorted")), m_Sorted));
    }
    if(m_UnsortedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("unsorted")), m_Unsorted));
    }
    if(m_EmptyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("empty")), m_Empty));
    }
}

bool SortObject::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("sorted"))))
    {
        bool refVal_setSorted;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("sorted"))), refVal_setSorted );
        setSorted(refVal_setSorted);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("unsorted"))))
    {
        bool refVal_setUnsorted;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("unsorted"))), refVal_setUnsorted );
        setUnsorted(refVal_setUnsorted);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("empty"))))
    {
        bool refVal_setEmpty;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("empty"))), refVal_setEmpty );
        setEmpty(refVal_setEmpty);
    }
    return ok;
}

bool SortObject::isSorted() const
{
    return m_Sorted;
}

void SortObject::setSorted(bool value)
{
    m_Sorted = value;
    m_SortedIsSet = true;
}

bool SortObject::sortedIsSet() const
{
    return m_SortedIsSet;
}

void SortObject::unsetSorted()
{
    m_SortedIsSet = false;
}
bool SortObject::isUnsorted() const
{
    return m_Unsorted;
}

void SortObject::setUnsorted(bool value)
{
    m_Unsorted = value;
    m_UnsortedIsSet = true;
}

bool SortObject::unsortedIsSet() const
{
    return m_UnsortedIsSet;
}

void SortObject::unsetUnsorted()
{
    m_UnsortedIsSet = false;
}
bool SortObject::isEmpty() const
{
    return m_Empty;
}

void SortObject::setEmpty(bool value)
{
    m_Empty = value;
    m_EmptyIsSet = true;
}

bool SortObject::emptyIsSet() const
{
    return m_EmptyIsSet;
}

void SortObject::unsetEmpty()
{
    m_EmptyIsSet = false;
}
}
}
}
}


