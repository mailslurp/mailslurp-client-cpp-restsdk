/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/ExportOptions.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



ExportOptions::ExportOptions()
{
    m_OutputFormat = utility::conversions::to_string_t("");
    m_OutputFormatIsSet = false;
    m_ExcludePreviouslyExported = false;
    m_ExcludePreviouslyExportedIsSet = false;
    m_CreatedEarliestTime = utility::datetime();
    m_CreatedEarliestTimeIsSet = false;
    m_CreatedOldestTime = utility::datetime();
    m_CreatedOldestTimeIsSet = false;
    m_Filter = utility::conversions::to_string_t("");
    m_FilterIsSet = false;
    m_ListSeparatorToken = utility::conversions::to_string_t("");
    m_ListSeparatorTokenIsSet = false;
}

ExportOptions::~ExportOptions()
{
}

void ExportOptions::validate()
{
    // TODO: implement validation
}

web::json::value ExportOptions::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_OutputFormatIsSet)
    {
        val[utility::conversions::to_string_t(U("outputFormat"))] = ModelBase::toJson(m_OutputFormat);
    }
    if(m_ExcludePreviouslyExportedIsSet)
    {
        val[utility::conversions::to_string_t(U("excludePreviouslyExported"))] = ModelBase::toJson(m_ExcludePreviouslyExported);
    }
    if(m_CreatedEarliestTimeIsSet)
    {
        val[utility::conversions::to_string_t(U("createdEarliestTime"))] = ModelBase::toJson(m_CreatedEarliestTime);
    }
    if(m_CreatedOldestTimeIsSet)
    {
        val[utility::conversions::to_string_t(U("createdOldestTime"))] = ModelBase::toJson(m_CreatedOldestTime);
    }
    if(m_FilterIsSet)
    {
        val[utility::conversions::to_string_t(U("filter"))] = ModelBase::toJson(m_Filter);
    }
    if(m_ListSeparatorTokenIsSet)
    {
        val[utility::conversions::to_string_t(U("listSeparatorToken"))] = ModelBase::toJson(m_ListSeparatorToken);
    }

    return val;
}

bool ExportOptions::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("outputFormat"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("outputFormat")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setOutputFormat;
            ok &= ModelBase::fromJson(fieldValue, refVal_setOutputFormat);
            setOutputFormat(refVal_setOutputFormat);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("excludePreviouslyExported"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("excludePreviouslyExported")));
        if(!fieldValue.is_null())
        {
            bool refVal_setExcludePreviouslyExported;
            ok &= ModelBase::fromJson(fieldValue, refVal_setExcludePreviouslyExported);
            setExcludePreviouslyExported(refVal_setExcludePreviouslyExported);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("createdEarliestTime"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("createdEarliestTime")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setCreatedEarliestTime;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCreatedEarliestTime);
            setCreatedEarliestTime(refVal_setCreatedEarliestTime);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("createdOldestTime"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("createdOldestTime")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setCreatedOldestTime;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCreatedOldestTime);
            setCreatedOldestTime(refVal_setCreatedOldestTime);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("filter"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("filter")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setFilter;
            ok &= ModelBase::fromJson(fieldValue, refVal_setFilter);
            setFilter(refVal_setFilter);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("listSeparatorToken"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("listSeparatorToken")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setListSeparatorToken;
            ok &= ModelBase::fromJson(fieldValue, refVal_setListSeparatorToken);
            setListSeparatorToken(refVal_setListSeparatorToken);
        }
    }
    return ok;
}

void ExportOptions::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_OutputFormatIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("outputFormat")), m_OutputFormat));
    }
    if(m_ExcludePreviouslyExportedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("excludePreviouslyExported")), m_ExcludePreviouslyExported));
    }
    if(m_CreatedEarliestTimeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("createdEarliestTime")), m_CreatedEarliestTime));
    }
    if(m_CreatedOldestTimeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("createdOldestTime")), m_CreatedOldestTime));
    }
    if(m_FilterIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("filter")), m_Filter));
    }
    if(m_ListSeparatorTokenIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("listSeparatorToken")), m_ListSeparatorToken));
    }
}

bool ExportOptions::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("outputFormat"))))
    {
        utility::string_t refVal_setOutputFormat;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("outputFormat"))), refVal_setOutputFormat );
        setOutputFormat(refVal_setOutputFormat);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("excludePreviouslyExported"))))
    {
        bool refVal_setExcludePreviouslyExported;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("excludePreviouslyExported"))), refVal_setExcludePreviouslyExported );
        setExcludePreviouslyExported(refVal_setExcludePreviouslyExported);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("createdEarliestTime"))))
    {
        utility::datetime refVal_setCreatedEarliestTime;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("createdEarliestTime"))), refVal_setCreatedEarliestTime );
        setCreatedEarliestTime(refVal_setCreatedEarliestTime);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("createdOldestTime"))))
    {
        utility::datetime refVal_setCreatedOldestTime;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("createdOldestTime"))), refVal_setCreatedOldestTime );
        setCreatedOldestTime(refVal_setCreatedOldestTime);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("filter"))))
    {
        utility::string_t refVal_setFilter;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("filter"))), refVal_setFilter );
        setFilter(refVal_setFilter);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("listSeparatorToken"))))
    {
        utility::string_t refVal_setListSeparatorToken;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("listSeparatorToken"))), refVal_setListSeparatorToken );
        setListSeparatorToken(refVal_setListSeparatorToken);
    }
    return ok;
}

utility::string_t ExportOptions::getOutputFormat() const
{
    return m_OutputFormat;
}

void ExportOptions::setOutputFormat(const utility::string_t& value)
{
    m_OutputFormat = value;
    m_OutputFormatIsSet = true;
}

bool ExportOptions::outputFormatIsSet() const
{
    return m_OutputFormatIsSet;
}

void ExportOptions::unsetOutputFormat()
{
    m_OutputFormatIsSet = false;
}
bool ExportOptions::isExcludePreviouslyExported() const
{
    return m_ExcludePreviouslyExported;
}

void ExportOptions::setExcludePreviouslyExported(bool value)
{
    m_ExcludePreviouslyExported = value;
    m_ExcludePreviouslyExportedIsSet = true;
}

bool ExportOptions::excludePreviouslyExportedIsSet() const
{
    return m_ExcludePreviouslyExportedIsSet;
}

void ExportOptions::unsetExcludePreviouslyExported()
{
    m_ExcludePreviouslyExportedIsSet = false;
}
utility::datetime ExportOptions::getCreatedEarliestTime() const
{
    return m_CreatedEarliestTime;
}

void ExportOptions::setCreatedEarliestTime(const utility::datetime& value)
{
    m_CreatedEarliestTime = value;
    m_CreatedEarliestTimeIsSet = true;
}

bool ExportOptions::createdEarliestTimeIsSet() const
{
    return m_CreatedEarliestTimeIsSet;
}

void ExportOptions::unsetCreatedEarliestTime()
{
    m_CreatedEarliestTimeIsSet = false;
}
utility::datetime ExportOptions::getCreatedOldestTime() const
{
    return m_CreatedOldestTime;
}

void ExportOptions::setCreatedOldestTime(const utility::datetime& value)
{
    m_CreatedOldestTime = value;
    m_CreatedOldestTimeIsSet = true;
}

bool ExportOptions::createdOldestTimeIsSet() const
{
    return m_CreatedOldestTimeIsSet;
}

void ExportOptions::unsetCreatedOldestTime()
{
    m_CreatedOldestTimeIsSet = false;
}
utility::string_t ExportOptions::getFilter() const
{
    return m_Filter;
}

void ExportOptions::setFilter(const utility::string_t& value)
{
    m_Filter = value;
    m_FilterIsSet = true;
}

bool ExportOptions::filterIsSet() const
{
    return m_FilterIsSet;
}

void ExportOptions::unsetFilter()
{
    m_FilterIsSet = false;
}
utility::string_t ExportOptions::getListSeparatorToken() const
{
    return m_ListSeparatorToken;
}

void ExportOptions::setListSeparatorToken(const utility::string_t& value)
{
    m_ListSeparatorToken = value;
    m_ListSeparatorTokenIsSet = true;
}

bool ExportOptions::listSeparatorTokenIsSet() const
{
    return m_ListSeparatorTokenIsSet;
}

void ExportOptions::unsetListSeparatorToken()
{
    m_ListSeparatorTokenIsSet = false;
}
}
}
}
}


