/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/TestRulesetSendingResult.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



TestRulesetSendingResult::TestRulesetSendingResult()
{
    m_CanSend = false;
    m_CanSendIsSet = false;
}

TestRulesetSendingResult::~TestRulesetSendingResult()
{
}

void TestRulesetSendingResult::validate()
{
    // TODO: implement validation
}

web::json::value TestRulesetSendingResult::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_CanSendIsSet)
    {
        val[utility::conversions::to_string_t(U("canSend"))] = ModelBase::toJson(m_CanSend);
    }

    return val;
}

bool TestRulesetSendingResult::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("canSend"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("canSend")));
        if(!fieldValue.is_null())
        {
            bool refVal_setCanSend;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCanSend);
            setCanSend(refVal_setCanSend);
        }
    }
    return ok;
}

void TestRulesetSendingResult::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_CanSendIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("canSend")), m_CanSend));
    }
}

bool TestRulesetSendingResult::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("canSend"))))
    {
        bool refVal_setCanSend;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("canSend"))), refVal_setCanSend );
        setCanSend(refVal_setCanSend);
    }
    return ok;
}

bool TestRulesetSendingResult::isCanSend() const
{
    return m_CanSend;
}

void TestRulesetSendingResult::setCanSend(bool value)
{
    m_CanSend = value;
    m_CanSendIsSet = true;
}

bool TestRulesetSendingResult::canSendIsSet() const
{
    return m_CanSendIsSet;
}

void TestRulesetSendingResult::unsetCanSend()
{
    m_CanSendIsSet = false;
}
}
}
}
}


