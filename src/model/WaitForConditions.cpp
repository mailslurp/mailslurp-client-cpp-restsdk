/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/WaitForConditions.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



WaitForConditions::WaitForConditions()
{
    m_InboxId = utility::conversions::to_string_t("");
    m_InboxIdIsSet = false;
    m_Count = 0;
    m_CountIsSet = false;
    m_DelayTimeout = 0L;
    m_DelayTimeoutIsSet = false;
    m_Timeout = 0L;
    m_TimeoutIsSet = false;
    m_UnreadOnly = false;
    m_UnreadOnlyIsSet = false;
    m_CountType = utility::conversions::to_string_t("");
    m_CountTypeIsSet = false;
    m_MatchesIsSet = false;
    m_SortDirection = utility::conversions::to_string_t("");
    m_SortDirectionIsSet = false;
    m_Since = utility::datetime();
    m_SinceIsSet = false;
    m_Before = utility::datetime();
    m_BeforeIsSet = false;
}

WaitForConditions::~WaitForConditions()
{
}

void WaitForConditions::validate()
{
    // TODO: implement validation
}

web::json::value WaitForConditions::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_InboxIdIsSet)
    {
        val[utility::conversions::to_string_t(U("inboxId"))] = ModelBase::toJson(m_InboxId);
    }
    if(m_CountIsSet)
    {
        val[utility::conversions::to_string_t(U("count"))] = ModelBase::toJson(m_Count);
    }
    if(m_DelayTimeoutIsSet)
    {
        val[utility::conversions::to_string_t(U("delayTimeout"))] = ModelBase::toJson(m_DelayTimeout);
    }
    if(m_TimeoutIsSet)
    {
        val[utility::conversions::to_string_t(U("timeout"))] = ModelBase::toJson(m_Timeout);
    }
    if(m_UnreadOnlyIsSet)
    {
        val[utility::conversions::to_string_t(U("unreadOnly"))] = ModelBase::toJson(m_UnreadOnly);
    }
    if(m_CountTypeIsSet)
    {
        val[utility::conversions::to_string_t(U("countType"))] = ModelBase::toJson(m_CountType);
    }
    if(m_MatchesIsSet)
    {
        val[utility::conversions::to_string_t(U("matches"))] = ModelBase::toJson(m_Matches);
    }
    if(m_SortDirectionIsSet)
    {
        val[utility::conversions::to_string_t(U("sortDirection"))] = ModelBase::toJson(m_SortDirection);
    }
    if(m_SinceIsSet)
    {
        val[utility::conversions::to_string_t(U("since"))] = ModelBase::toJson(m_Since);
    }
    if(m_BeforeIsSet)
    {
        val[utility::conversions::to_string_t(U("before"))] = ModelBase::toJson(m_Before);
    }

    return val;
}

bool WaitForConditions::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("inboxId"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("inboxId")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setInboxId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setInboxId);
            setInboxId(refVal_setInboxId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("count"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("count")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setCount;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCount);
            setCount(refVal_setCount);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("delayTimeout"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("delayTimeout")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setDelayTimeout;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDelayTimeout);
            setDelayTimeout(refVal_setDelayTimeout);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("timeout"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("timeout")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setTimeout;
            ok &= ModelBase::fromJson(fieldValue, refVal_setTimeout);
            setTimeout(refVal_setTimeout);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("unreadOnly"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("unreadOnly")));
        if(!fieldValue.is_null())
        {
            bool refVal_setUnreadOnly;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUnreadOnly);
            setUnreadOnly(refVal_setUnreadOnly);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("countType"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("countType")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setCountType;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCountType);
            setCountType(refVal_setCountType);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("matches"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("matches")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<MatchOption>> refVal_setMatches;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMatches);
            setMatches(refVal_setMatches);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("sortDirection"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("sortDirection")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setSortDirection;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSortDirection);
            setSortDirection(refVal_setSortDirection);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("since"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("since")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setSince;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSince);
            setSince(refVal_setSince);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("before"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("before")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setBefore;
            ok &= ModelBase::fromJson(fieldValue, refVal_setBefore);
            setBefore(refVal_setBefore);
        }
    }
    return ok;
}

void WaitForConditions::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_InboxIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("inboxId")), m_InboxId));
    }
    if(m_CountIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("count")), m_Count));
    }
    if(m_DelayTimeoutIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("delayTimeout")), m_DelayTimeout));
    }
    if(m_TimeoutIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("timeout")), m_Timeout));
    }
    if(m_UnreadOnlyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("unreadOnly")), m_UnreadOnly));
    }
    if(m_CountTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("countType")), m_CountType));
    }
    if(m_MatchesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("matches")), m_Matches));
    }
    if(m_SortDirectionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("sortDirection")), m_SortDirection));
    }
    if(m_SinceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("since")), m_Since));
    }
    if(m_BeforeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("before")), m_Before));
    }
}

bool WaitForConditions::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("inboxId"))))
    {
        utility::string_t refVal_setInboxId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("inboxId"))), refVal_setInboxId );
        setInboxId(refVal_setInboxId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("count"))))
    {
        int32_t refVal_setCount;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("count"))), refVal_setCount );
        setCount(refVal_setCount);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("delayTimeout"))))
    {
        int64_t refVal_setDelayTimeout;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("delayTimeout"))), refVal_setDelayTimeout );
        setDelayTimeout(refVal_setDelayTimeout);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("timeout"))))
    {
        int64_t refVal_setTimeout;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("timeout"))), refVal_setTimeout );
        setTimeout(refVal_setTimeout);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("unreadOnly"))))
    {
        bool refVal_setUnreadOnly;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("unreadOnly"))), refVal_setUnreadOnly );
        setUnreadOnly(refVal_setUnreadOnly);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("countType"))))
    {
        utility::string_t refVal_setCountType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("countType"))), refVal_setCountType );
        setCountType(refVal_setCountType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("matches"))))
    {
        std::vector<std::shared_ptr<MatchOption>> refVal_setMatches;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("matches"))), refVal_setMatches );
        setMatches(refVal_setMatches);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("sortDirection"))))
    {
        utility::string_t refVal_setSortDirection;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("sortDirection"))), refVal_setSortDirection );
        setSortDirection(refVal_setSortDirection);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("since"))))
    {
        utility::datetime refVal_setSince;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("since"))), refVal_setSince );
        setSince(refVal_setSince);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("before"))))
    {
        utility::datetime refVal_setBefore;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("before"))), refVal_setBefore );
        setBefore(refVal_setBefore);
    }
    return ok;
}

utility::string_t WaitForConditions::getInboxId() const
{
    return m_InboxId;
}

void WaitForConditions::setInboxId(const utility::string_t& value)
{
    m_InboxId = value;
    m_InboxIdIsSet = true;
}

bool WaitForConditions::inboxIdIsSet() const
{
    return m_InboxIdIsSet;
}

void WaitForConditions::unsetInboxId()
{
    m_InboxIdIsSet = false;
}
int32_t WaitForConditions::getCount() const
{
    return m_Count;
}

void WaitForConditions::setCount(int32_t value)
{
    m_Count = value;
    m_CountIsSet = true;
}

bool WaitForConditions::countIsSet() const
{
    return m_CountIsSet;
}

void WaitForConditions::unsetCount()
{
    m_CountIsSet = false;
}
int64_t WaitForConditions::getDelayTimeout() const
{
    return m_DelayTimeout;
}

void WaitForConditions::setDelayTimeout(int64_t value)
{
    m_DelayTimeout = value;
    m_DelayTimeoutIsSet = true;
}

bool WaitForConditions::delayTimeoutIsSet() const
{
    return m_DelayTimeoutIsSet;
}

void WaitForConditions::unsetDelayTimeout()
{
    m_DelayTimeoutIsSet = false;
}
int64_t WaitForConditions::getTimeout() const
{
    return m_Timeout;
}

void WaitForConditions::setTimeout(int64_t value)
{
    m_Timeout = value;
    m_TimeoutIsSet = true;
}

bool WaitForConditions::timeoutIsSet() const
{
    return m_TimeoutIsSet;
}

void WaitForConditions::unsetTimeout()
{
    m_TimeoutIsSet = false;
}
bool WaitForConditions::isUnreadOnly() const
{
    return m_UnreadOnly;
}

void WaitForConditions::setUnreadOnly(bool value)
{
    m_UnreadOnly = value;
    m_UnreadOnlyIsSet = true;
}

bool WaitForConditions::unreadOnlyIsSet() const
{
    return m_UnreadOnlyIsSet;
}

void WaitForConditions::unsetUnreadOnly()
{
    m_UnreadOnlyIsSet = false;
}
utility::string_t WaitForConditions::getCountType() const
{
    return m_CountType;
}

void WaitForConditions::setCountType(const utility::string_t& value)
{
    m_CountType = value;
    m_CountTypeIsSet = true;
}

bool WaitForConditions::countTypeIsSet() const
{
    return m_CountTypeIsSet;
}

void WaitForConditions::unsetCountType()
{
    m_CountTypeIsSet = false;
}
std::vector<std::shared_ptr<MatchOption>>& WaitForConditions::getMatches()
{
    return m_Matches;
}

void WaitForConditions::setMatches(const std::vector<std::shared_ptr<MatchOption>>& value)
{
    m_Matches = value;
    m_MatchesIsSet = true;
}

bool WaitForConditions::matchesIsSet() const
{
    return m_MatchesIsSet;
}

void WaitForConditions::unsetMatches()
{
    m_MatchesIsSet = false;
}
utility::string_t WaitForConditions::getSortDirection() const
{
    return m_SortDirection;
}

void WaitForConditions::setSortDirection(const utility::string_t& value)
{
    m_SortDirection = value;
    m_SortDirectionIsSet = true;
}

bool WaitForConditions::sortDirectionIsSet() const
{
    return m_SortDirectionIsSet;
}

void WaitForConditions::unsetSortDirection()
{
    m_SortDirectionIsSet = false;
}
utility::datetime WaitForConditions::getSince() const
{
    return m_Since;
}

void WaitForConditions::setSince(const utility::datetime& value)
{
    m_Since = value;
    m_SinceIsSet = true;
}

bool WaitForConditions::sinceIsSet() const
{
    return m_SinceIsSet;
}

void WaitForConditions::unsetSince()
{
    m_SinceIsSet = false;
}
utility::datetime WaitForConditions::getBefore() const
{
    return m_Before;
}

void WaitForConditions::setBefore(const utility::datetime& value)
{
    m_Before = value;
    m_BeforeIsSet = true;
}

bool WaitForConditions::beforeIsSet() const
{
    return m_BeforeIsSet;
}

void WaitForConditions::unsetBefore()
{
    m_BeforeIsSet = false;
}
}
}
}
}


