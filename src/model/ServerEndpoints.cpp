/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/ServerEndpoints.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



ServerEndpoints::ServerEndpoints()
{
    m_Host = utility::conversions::to_string_t("");
    m_HostIsSet = false;
    m_Port = 0;
    m_PortIsSet = false;
    m_Tls = false;
    m_TlsIsSet = false;
    m_AltPortsIsSet = false;
}

ServerEndpoints::~ServerEndpoints()
{
}

void ServerEndpoints::validate()
{
    // TODO: implement validation
}

web::json::value ServerEndpoints::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_HostIsSet)
    {
        val[utility::conversions::to_string_t(U("host"))] = ModelBase::toJson(m_Host);
    }
    if(m_PortIsSet)
    {
        val[utility::conversions::to_string_t(U("port"))] = ModelBase::toJson(m_Port);
    }
    if(m_TlsIsSet)
    {
        val[utility::conversions::to_string_t(U("tls"))] = ModelBase::toJson(m_Tls);
    }
    if(m_AltPortsIsSet)
    {
        val[utility::conversions::to_string_t(U("altPorts"))] = ModelBase::toJson(m_AltPorts);
    }

    return val;
}

bool ServerEndpoints::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("host"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("host")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setHost;
            ok &= ModelBase::fromJson(fieldValue, refVal_setHost);
            setHost(refVal_setHost);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("port"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("port")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setPort;
            ok &= ModelBase::fromJson(fieldValue, refVal_setPort);
            setPort(refVal_setPort);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("tls"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("tls")));
        if(!fieldValue.is_null())
        {
            bool refVal_setTls;
            ok &= ModelBase::fromJson(fieldValue, refVal_setTls);
            setTls(refVal_setTls);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("altPorts"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("altPorts")));
        if(!fieldValue.is_null())
        {
            std::vector<int32_t> refVal_setAltPorts;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAltPorts);
            setAltPorts(refVal_setAltPorts);
        }
    }
    return ok;
}

void ServerEndpoints::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_HostIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("host")), m_Host));
    }
    if(m_PortIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("port")), m_Port));
    }
    if(m_TlsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("tls")), m_Tls));
    }
    if(m_AltPortsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("altPorts")), m_AltPorts));
    }
}

bool ServerEndpoints::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("host"))))
    {
        utility::string_t refVal_setHost;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("host"))), refVal_setHost );
        setHost(refVal_setHost);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("port"))))
    {
        int32_t refVal_setPort;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("port"))), refVal_setPort );
        setPort(refVal_setPort);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("tls"))))
    {
        bool refVal_setTls;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("tls"))), refVal_setTls );
        setTls(refVal_setTls);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("altPorts"))))
    {
        std::vector<int32_t> refVal_setAltPorts;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("altPorts"))), refVal_setAltPorts );
        setAltPorts(refVal_setAltPorts);
    }
    return ok;
}

utility::string_t ServerEndpoints::getHost() const
{
    return m_Host;
}

void ServerEndpoints::setHost(const utility::string_t& value)
{
    m_Host = value;
    m_HostIsSet = true;
}

bool ServerEndpoints::hostIsSet() const
{
    return m_HostIsSet;
}

void ServerEndpoints::unsetHost()
{
    m_HostIsSet = false;
}
int32_t ServerEndpoints::getPort() const
{
    return m_Port;
}

void ServerEndpoints::setPort(int32_t value)
{
    m_Port = value;
    m_PortIsSet = true;
}

bool ServerEndpoints::portIsSet() const
{
    return m_PortIsSet;
}

void ServerEndpoints::unsetPort()
{
    m_PortIsSet = false;
}
bool ServerEndpoints::isTls() const
{
    return m_Tls;
}

void ServerEndpoints::setTls(bool value)
{
    m_Tls = value;
    m_TlsIsSet = true;
}

bool ServerEndpoints::tlsIsSet() const
{
    return m_TlsIsSet;
}

void ServerEndpoints::unsetTls()
{
    m_TlsIsSet = false;
}
std::vector<int32_t>& ServerEndpoints::getAltPorts()
{
    return m_AltPorts;
}

void ServerEndpoints::setAltPorts(std::vector<int32_t> value)
{
    m_AltPorts = value;
    m_AltPortsIsSet = true;
}

bool ServerEndpoints::altPortsIsSet() const
{
    return m_AltPortsIsSet;
}

void ServerEndpoints::unsetAltPorts()
{
    m_AltPortsIsSet = false;
}
}
}
}
}


