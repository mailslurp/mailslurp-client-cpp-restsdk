/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/InvokeTransformerOptions.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



InvokeTransformerOptions::InvokeTransformerOptions()
{
    m_AiTransformId = utility::conversions::to_string_t("");
    m_AiTransformIdIsSet = false;
    m_AiTransformMappingId = utility::conversions::to_string_t("");
    m_AiTransformMappingIdIsSet = false;
    m_RawInput = utility::conversions::to_string_t("");
    m_RawInputIsSet = false;
    m_EntityId = utility::conversions::to_string_t("");
    m_EntityIdIsSet = false;
    m_EntityType = utility::conversions::to_string_t("");
    m_EntityTypeIsSet = false;
    m_RawConditionsIsSet = false;
    m_RawInstructionsIsSet = false;
    m_RawOutputSchemaIsSet = false;
    m_ContentSelector = utility::conversions::to_string_t("");
    m_ContentSelectorIsSet = false;
}

InvokeTransformerOptions::~InvokeTransformerOptions()
{
}

void InvokeTransformerOptions::validate()
{
    // TODO: implement validation
}

web::json::value InvokeTransformerOptions::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_AiTransformIdIsSet)
    {
        val[utility::conversions::to_string_t(U("aiTransformId"))] = ModelBase::toJson(m_AiTransformId);
    }
    if(m_AiTransformMappingIdIsSet)
    {
        val[utility::conversions::to_string_t(U("aiTransformMappingId"))] = ModelBase::toJson(m_AiTransformMappingId);
    }
    if(m_RawInputIsSet)
    {
        val[utility::conversions::to_string_t(U("rawInput"))] = ModelBase::toJson(m_RawInput);
    }
    if(m_EntityIdIsSet)
    {
        val[utility::conversions::to_string_t(U("entityId"))] = ModelBase::toJson(m_EntityId);
    }
    if(m_EntityTypeIsSet)
    {
        val[utility::conversions::to_string_t(U("entityType"))] = ModelBase::toJson(m_EntityType);
    }
    if(m_RawConditionsIsSet)
    {
        val[utility::conversions::to_string_t(U("rawConditions"))] = ModelBase::toJson(m_RawConditions);
    }
    if(m_RawInstructionsIsSet)
    {
        val[utility::conversions::to_string_t(U("rawInstructions"))] = ModelBase::toJson(m_RawInstructions);
    }
    if(m_RawOutputSchemaIsSet)
    {
        val[utility::conversions::to_string_t(U("rawOutputSchema"))] = ModelBase::toJson(m_RawOutputSchema);
    }
    if(m_ContentSelectorIsSet)
    {
        val[utility::conversions::to_string_t(U("contentSelector"))] = ModelBase::toJson(m_ContentSelector);
    }

    return val;
}

bool InvokeTransformerOptions::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("aiTransformId"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("aiTransformId")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setAiTransformId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAiTransformId);
            setAiTransformId(refVal_setAiTransformId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("aiTransformMappingId"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("aiTransformMappingId")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setAiTransformMappingId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAiTransformMappingId);
            setAiTransformMappingId(refVal_setAiTransformMappingId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("rawInput"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("rawInput")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setRawInput;
            ok &= ModelBase::fromJson(fieldValue, refVal_setRawInput);
            setRawInput(refVal_setRawInput);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("entityId"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("entityId")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setEntityId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setEntityId);
            setEntityId(refVal_setEntityId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("entityType"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("entityType")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setEntityType;
            ok &= ModelBase::fromJson(fieldValue, refVal_setEntityType);
            setEntityType(refVal_setEntityType);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("rawConditions"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("rawConditions")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setRawConditions;
            ok &= ModelBase::fromJson(fieldValue, refVal_setRawConditions);
            setRawConditions(refVal_setRawConditions);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("rawInstructions"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("rawInstructions")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setRawInstructions;
            ok &= ModelBase::fromJson(fieldValue, refVal_setRawInstructions);
            setRawInstructions(refVal_setRawInstructions);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("rawOutputSchema"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("rawOutputSchema")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<StructuredOutputSchema> refVal_setRawOutputSchema;
            ok &= ModelBase::fromJson(fieldValue, refVal_setRawOutputSchema);
            setRawOutputSchema(refVal_setRawOutputSchema);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("contentSelector"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("contentSelector")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setContentSelector;
            ok &= ModelBase::fromJson(fieldValue, refVal_setContentSelector);
            setContentSelector(refVal_setContentSelector);
        }
    }
    return ok;
}

void InvokeTransformerOptions::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_AiTransformIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("aiTransformId")), m_AiTransformId));
    }
    if(m_AiTransformMappingIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("aiTransformMappingId")), m_AiTransformMappingId));
    }
    if(m_RawInputIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("rawInput")), m_RawInput));
    }
    if(m_EntityIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("entityId")), m_EntityId));
    }
    if(m_EntityTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("entityType")), m_EntityType));
    }
    if(m_RawConditionsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("rawConditions")), m_RawConditions));
    }
    if(m_RawInstructionsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("rawInstructions")), m_RawInstructions));
    }
    if(m_RawOutputSchemaIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("rawOutputSchema")), m_RawOutputSchema));
    }
    if(m_ContentSelectorIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("contentSelector")), m_ContentSelector));
    }
}

bool InvokeTransformerOptions::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("aiTransformId"))))
    {
        utility::string_t refVal_setAiTransformId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("aiTransformId"))), refVal_setAiTransformId );
        setAiTransformId(refVal_setAiTransformId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("aiTransformMappingId"))))
    {
        utility::string_t refVal_setAiTransformMappingId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("aiTransformMappingId"))), refVal_setAiTransformMappingId );
        setAiTransformMappingId(refVal_setAiTransformMappingId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("rawInput"))))
    {
        utility::string_t refVal_setRawInput;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("rawInput"))), refVal_setRawInput );
        setRawInput(refVal_setRawInput);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("entityId"))))
    {
        utility::string_t refVal_setEntityId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("entityId"))), refVal_setEntityId );
        setEntityId(refVal_setEntityId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("entityType"))))
    {
        utility::string_t refVal_setEntityType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("entityType"))), refVal_setEntityType );
        setEntityType(refVal_setEntityType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("rawConditions"))))
    {
        std::vector<utility::string_t> refVal_setRawConditions;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("rawConditions"))), refVal_setRawConditions );
        setRawConditions(refVal_setRawConditions);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("rawInstructions"))))
    {
        std::vector<utility::string_t> refVal_setRawInstructions;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("rawInstructions"))), refVal_setRawInstructions );
        setRawInstructions(refVal_setRawInstructions);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("rawOutputSchema"))))
    {
        std::shared_ptr<StructuredOutputSchema> refVal_setRawOutputSchema;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("rawOutputSchema"))), refVal_setRawOutputSchema );
        setRawOutputSchema(refVal_setRawOutputSchema);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("contentSelector"))))
    {
        utility::string_t refVal_setContentSelector;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("contentSelector"))), refVal_setContentSelector );
        setContentSelector(refVal_setContentSelector);
    }
    return ok;
}

utility::string_t InvokeTransformerOptions::getAiTransformId() const
{
    return m_AiTransformId;
}

void InvokeTransformerOptions::setAiTransformId(const utility::string_t& value)
{
    m_AiTransformId = value;
    m_AiTransformIdIsSet = true;
}

bool InvokeTransformerOptions::aiTransformIdIsSet() const
{
    return m_AiTransformIdIsSet;
}

void InvokeTransformerOptions::unsetAiTransformId()
{
    m_AiTransformIdIsSet = false;
}
utility::string_t InvokeTransformerOptions::getAiTransformMappingId() const
{
    return m_AiTransformMappingId;
}

void InvokeTransformerOptions::setAiTransformMappingId(const utility::string_t& value)
{
    m_AiTransformMappingId = value;
    m_AiTransformMappingIdIsSet = true;
}

bool InvokeTransformerOptions::aiTransformMappingIdIsSet() const
{
    return m_AiTransformMappingIdIsSet;
}

void InvokeTransformerOptions::unsetAiTransformMappingId()
{
    m_AiTransformMappingIdIsSet = false;
}
utility::string_t InvokeTransformerOptions::getRawInput() const
{
    return m_RawInput;
}

void InvokeTransformerOptions::setRawInput(const utility::string_t& value)
{
    m_RawInput = value;
    m_RawInputIsSet = true;
}

bool InvokeTransformerOptions::rawInputIsSet() const
{
    return m_RawInputIsSet;
}

void InvokeTransformerOptions::unsetRawInput()
{
    m_RawInputIsSet = false;
}
utility::string_t InvokeTransformerOptions::getEntityId() const
{
    return m_EntityId;
}

void InvokeTransformerOptions::setEntityId(const utility::string_t& value)
{
    m_EntityId = value;
    m_EntityIdIsSet = true;
}

bool InvokeTransformerOptions::entityIdIsSet() const
{
    return m_EntityIdIsSet;
}

void InvokeTransformerOptions::unsetEntityId()
{
    m_EntityIdIsSet = false;
}
utility::string_t InvokeTransformerOptions::getEntityType() const
{
    return m_EntityType;
}

void InvokeTransformerOptions::setEntityType(const utility::string_t& value)
{
    m_EntityType = value;
    m_EntityTypeIsSet = true;
}

bool InvokeTransformerOptions::entityTypeIsSet() const
{
    return m_EntityTypeIsSet;
}

void InvokeTransformerOptions::unsetEntityType()
{
    m_EntityTypeIsSet = false;
}
std::vector<utility::string_t>& InvokeTransformerOptions::getRawConditions()
{
    return m_RawConditions;
}

void InvokeTransformerOptions::setRawConditions(const std::vector<utility::string_t>& value)
{
    m_RawConditions = value;
    m_RawConditionsIsSet = true;
}

bool InvokeTransformerOptions::rawConditionsIsSet() const
{
    return m_RawConditionsIsSet;
}

void InvokeTransformerOptions::unsetRawConditions()
{
    m_RawConditionsIsSet = false;
}
std::vector<utility::string_t>& InvokeTransformerOptions::getRawInstructions()
{
    return m_RawInstructions;
}

void InvokeTransformerOptions::setRawInstructions(const std::vector<utility::string_t>& value)
{
    m_RawInstructions = value;
    m_RawInstructionsIsSet = true;
}

bool InvokeTransformerOptions::rawInstructionsIsSet() const
{
    return m_RawInstructionsIsSet;
}

void InvokeTransformerOptions::unsetRawInstructions()
{
    m_RawInstructionsIsSet = false;
}
std::shared_ptr<StructuredOutputSchema> InvokeTransformerOptions::getRawOutputSchema() const
{
    return m_RawOutputSchema;
}

void InvokeTransformerOptions::setRawOutputSchema(const std::shared_ptr<StructuredOutputSchema>& value)
{
    m_RawOutputSchema = value;
    m_RawOutputSchemaIsSet = true;
}

bool InvokeTransformerOptions::rawOutputSchemaIsSet() const
{
    return m_RawOutputSchemaIsSet;
}

void InvokeTransformerOptions::unsetRawOutputSchema()
{
    m_RawOutputSchemaIsSet = false;
}
utility::string_t InvokeTransformerOptions::getContentSelector() const
{
    return m_ContentSelector;
}

void InvokeTransformerOptions::setContentSelector(const utility::string_t& value)
{
    m_ContentSelector = value;
    m_ContentSelectorIsSet = true;
}

bool InvokeTransformerOptions::contentSelectorIsSet() const
{
    return m_ContentSelectorIsSet;
}

void InvokeTransformerOptions::unsetContentSelector()
{
    m_ContentSelectorIsSet = false;
}
}
}
}
}


