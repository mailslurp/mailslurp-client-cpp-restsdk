/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/ImapUpdateFlagsOptions.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



ImapUpdateFlagsOptions::ImapUpdateFlagsOptions()
{
    m_Operation = utility::conversions::to_string_t("");
    m_OperationIsSet = false;
    m_FlagsIsSet = false;
    m_UidSet = utility::conversions::to_string_t("");
    m_UidSetIsSet = false;
    m_SeqSet = utility::conversions::to_string_t("");
    m_SeqSetIsSet = false;
}

ImapUpdateFlagsOptions::~ImapUpdateFlagsOptions()
{
}

void ImapUpdateFlagsOptions::validate()
{
    // TODO: implement validation
}

web::json::value ImapUpdateFlagsOptions::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_OperationIsSet)
    {
        val[utility::conversions::to_string_t(U("operation"))] = ModelBase::toJson(m_Operation);
    }
    if(m_FlagsIsSet)
    {
        val[utility::conversions::to_string_t(U("flags"))] = ModelBase::toJson(m_Flags);
    }
    if(m_UidSetIsSet)
    {
        val[utility::conversions::to_string_t(U("uidSet"))] = ModelBase::toJson(m_UidSet);
    }
    if(m_SeqSetIsSet)
    {
        val[utility::conversions::to_string_t(U("seqSet"))] = ModelBase::toJson(m_SeqSet);
    }

    return val;
}

bool ImapUpdateFlagsOptions::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("operation"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("operation")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setOperation;
            ok &= ModelBase::fromJson(fieldValue, refVal_setOperation);
            setOperation(refVal_setOperation);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("flags"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("flags")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setFlags;
            ok &= ModelBase::fromJson(fieldValue, refVal_setFlags);
            setFlags(refVal_setFlags);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("uidSet"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("uidSet")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setUidSet;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUidSet);
            setUidSet(refVal_setUidSet);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("seqSet"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("seqSet")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setSeqSet;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSeqSet);
            setSeqSet(refVal_setSeqSet);
        }
    }
    return ok;
}

void ImapUpdateFlagsOptions::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_OperationIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("operation")), m_Operation));
    }
    if(m_FlagsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("flags")), m_Flags));
    }
    if(m_UidSetIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("uidSet")), m_UidSet));
    }
    if(m_SeqSetIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("seqSet")), m_SeqSet));
    }
}

bool ImapUpdateFlagsOptions::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("operation"))))
    {
        utility::string_t refVal_setOperation;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("operation"))), refVal_setOperation );
        setOperation(refVal_setOperation);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("flags"))))
    {
        std::vector<utility::string_t> refVal_setFlags;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("flags"))), refVal_setFlags );
        setFlags(refVal_setFlags);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("uidSet"))))
    {
        utility::string_t refVal_setUidSet;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("uidSet"))), refVal_setUidSet );
        setUidSet(refVal_setUidSet);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("seqSet"))))
    {
        utility::string_t refVal_setSeqSet;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("seqSet"))), refVal_setSeqSet );
        setSeqSet(refVal_setSeqSet);
    }
    return ok;
}

utility::string_t ImapUpdateFlagsOptions::getOperation() const
{
    return m_Operation;
}

void ImapUpdateFlagsOptions::setOperation(const utility::string_t& value)
{
    m_Operation = value;
    m_OperationIsSet = true;
}

bool ImapUpdateFlagsOptions::operationIsSet() const
{
    return m_OperationIsSet;
}

void ImapUpdateFlagsOptions::unsetOperation()
{
    m_OperationIsSet = false;
}
std::vector<utility::string_t>& ImapUpdateFlagsOptions::getFlags()
{
    return m_Flags;
}

void ImapUpdateFlagsOptions::setFlags(const std::vector<utility::string_t>& value)
{
    m_Flags = value;
    m_FlagsIsSet = true;
}

bool ImapUpdateFlagsOptions::flagsIsSet() const
{
    return m_FlagsIsSet;
}

void ImapUpdateFlagsOptions::unsetFlags()
{
    m_FlagsIsSet = false;
}
utility::string_t ImapUpdateFlagsOptions::getUidSet() const
{
    return m_UidSet;
}

void ImapUpdateFlagsOptions::setUidSet(const utility::string_t& value)
{
    m_UidSet = value;
    m_UidSetIsSet = true;
}

bool ImapUpdateFlagsOptions::uidSetIsSet() const
{
    return m_UidSetIsSet;
}

void ImapUpdateFlagsOptions::unsetUidSet()
{
    m_UidSetIsSet = false;
}
utility::string_t ImapUpdateFlagsOptions::getSeqSet() const
{
    return m_SeqSet;
}

void ImapUpdateFlagsOptions::setSeqSet(const utility::string_t& value)
{
    m_SeqSet = value;
    m_SeqSetIsSet = true;
}

bool ImapUpdateFlagsOptions::seqSetIsSet() const
{
    return m_SeqSetIsSet;
}

void ImapUpdateFlagsOptions::unsetSeqSet()
{
    m_SeqSetIsSet = false;
}
}
}
}
}


