/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/InboxDto.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



InboxDto::InboxDto()
{
    m_Id = utility::conversions::to_string_t("");
    m_IdIsSet = false;
    m_UserId = utility::conversions::to_string_t("");
    m_UserIdIsSet = false;
    m_CreatedAt = utility::datetime();
    m_CreatedAtIsSet = false;
    m_Name = utility::conversions::to_string_t("");
    m_NameIsSet = false;
    m_DomainId = utility::conversions::to_string_t("");
    m_DomainIdIsSet = false;
    m_Description = utility::conversions::to_string_t("");
    m_DescriptionIsSet = false;
    m_EmailAddress = utility::conversions::to_string_t("");
    m_EmailAddressIsSet = false;
    m_ExpiresAt = utility::conversions::to_string_t("");
    m_ExpiresAtIsSet = false;
    m_Favourite = false;
    m_FavouriteIsSet = false;
    m_TagsIsSet = false;
    m_InboxType = utility::conversions::to_string_t("");
    m_InboxTypeIsSet = false;
    m_ReadOnly = false;
    m_ReadOnlyIsSet = false;
    m_VirtualInbox = false;
    m_VirtualInboxIsSet = false;
    m_FunctionsAs = utility::conversions::to_string_t("");
    m_FunctionsAsIsSet = false;
}

InboxDto::~InboxDto()
{
}

void InboxDto::validate()
{
    // TODO: implement validation
}

web::json::value InboxDto::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_IdIsSet)
    {
        val[utility::conversions::to_string_t(U("id"))] = ModelBase::toJson(m_Id);
    }
    if(m_UserIdIsSet)
    {
        val[utility::conversions::to_string_t(U("userId"))] = ModelBase::toJson(m_UserId);
    }
    if(m_CreatedAtIsSet)
    {
        val[utility::conversions::to_string_t(U("createdAt"))] = ModelBase::toJson(m_CreatedAt);
    }
    if(m_NameIsSet)
    {
        val[utility::conversions::to_string_t(U("name"))] = ModelBase::toJson(m_Name);
    }
    if(m_DomainIdIsSet)
    {
        val[utility::conversions::to_string_t(U("domainId"))] = ModelBase::toJson(m_DomainId);
    }
    if(m_DescriptionIsSet)
    {
        val[utility::conversions::to_string_t(U("description"))] = ModelBase::toJson(m_Description);
    }
    if(m_EmailAddressIsSet)
    {
        val[utility::conversions::to_string_t(U("emailAddress"))] = ModelBase::toJson(m_EmailAddress);
    }
    if(m_ExpiresAtIsSet)
    {
        val[utility::conversions::to_string_t(U("expiresAt"))] = ModelBase::toJson(m_ExpiresAt);
    }
    if(m_FavouriteIsSet)
    {
        val[utility::conversions::to_string_t(U("favourite"))] = ModelBase::toJson(m_Favourite);
    }
    if(m_TagsIsSet)
    {
        val[utility::conversions::to_string_t(U("tags"))] = ModelBase::toJson(m_Tags);
    }
    if(m_InboxTypeIsSet)
    {
        val[utility::conversions::to_string_t(U("inboxType"))] = ModelBase::toJson(m_InboxType);
    }
    if(m_ReadOnlyIsSet)
    {
        val[utility::conversions::to_string_t(U("readOnly"))] = ModelBase::toJson(m_ReadOnly);
    }
    if(m_VirtualInboxIsSet)
    {
        val[utility::conversions::to_string_t(U("virtualInbox"))] = ModelBase::toJson(m_VirtualInbox);
    }
    if(m_FunctionsAsIsSet)
    {
        val[utility::conversions::to_string_t(U("functionsAs"))] = ModelBase::toJson(m_FunctionsAs);
    }

    return val;
}

bool InboxDto::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("id"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("id")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setId);
            setId(refVal_setId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("userId"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("userId")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setUserId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUserId);
            setUserId(refVal_setUserId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("createdAt"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("createdAt")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setCreatedAt;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCreatedAt);
            setCreatedAt(refVal_setCreatedAt);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("name"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("name")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setName;
            ok &= ModelBase::fromJson(fieldValue, refVal_setName);
            setName(refVal_setName);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("domainId"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("domainId")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setDomainId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDomainId);
            setDomainId(refVal_setDomainId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("description"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("description")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setDescription;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDescription);
            setDescription(refVal_setDescription);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("emailAddress"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("emailAddress")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setEmailAddress;
            ok &= ModelBase::fromJson(fieldValue, refVal_setEmailAddress);
            setEmailAddress(refVal_setEmailAddress);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("expiresAt"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("expiresAt")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setExpiresAt;
            ok &= ModelBase::fromJson(fieldValue, refVal_setExpiresAt);
            setExpiresAt(refVal_setExpiresAt);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("favourite"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("favourite")));
        if(!fieldValue.is_null())
        {
            bool refVal_setFavourite;
            ok &= ModelBase::fromJson(fieldValue, refVal_setFavourite);
            setFavourite(refVal_setFavourite);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("tags"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("tags")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setTags;
            ok &= ModelBase::fromJson(fieldValue, refVal_setTags);
            setTags(refVal_setTags);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("inboxType"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("inboxType")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setInboxType;
            ok &= ModelBase::fromJson(fieldValue, refVal_setInboxType);
            setInboxType(refVal_setInboxType);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("readOnly"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("readOnly")));
        if(!fieldValue.is_null())
        {
            bool refVal_setReadOnly;
            ok &= ModelBase::fromJson(fieldValue, refVal_setReadOnly);
            setReadOnly(refVal_setReadOnly);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("virtualInbox"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("virtualInbox")));
        if(!fieldValue.is_null())
        {
            bool refVal_setVirtualInbox;
            ok &= ModelBase::fromJson(fieldValue, refVal_setVirtualInbox);
            setVirtualInbox(refVal_setVirtualInbox);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("functionsAs"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("functionsAs")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setFunctionsAs;
            ok &= ModelBase::fromJson(fieldValue, refVal_setFunctionsAs);
            setFunctionsAs(refVal_setFunctionsAs);
        }
    }
    return ok;
}

void InboxDto::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_IdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("id")), m_Id));
    }
    if(m_UserIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("userId")), m_UserId));
    }
    if(m_CreatedAtIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("createdAt")), m_CreatedAt));
    }
    if(m_NameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("name")), m_Name));
    }
    if(m_DomainIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("domainId")), m_DomainId));
    }
    if(m_DescriptionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("description")), m_Description));
    }
    if(m_EmailAddressIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("emailAddress")), m_EmailAddress));
    }
    if(m_ExpiresAtIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("expiresAt")), m_ExpiresAt));
    }
    if(m_FavouriteIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("favourite")), m_Favourite));
    }
    if(m_TagsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("tags")), m_Tags));
    }
    if(m_InboxTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("inboxType")), m_InboxType));
    }
    if(m_ReadOnlyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("readOnly")), m_ReadOnly));
    }
    if(m_VirtualInboxIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("virtualInbox")), m_VirtualInbox));
    }
    if(m_FunctionsAsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("functionsAs")), m_FunctionsAs));
    }
}

bool InboxDto::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("id"))))
    {
        utility::string_t refVal_setId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("id"))), refVal_setId );
        setId(refVal_setId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("userId"))))
    {
        utility::string_t refVal_setUserId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("userId"))), refVal_setUserId );
        setUserId(refVal_setUserId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("createdAt"))))
    {
        utility::datetime refVal_setCreatedAt;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("createdAt"))), refVal_setCreatedAt );
        setCreatedAt(refVal_setCreatedAt);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("name"))))
    {
        utility::string_t refVal_setName;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("name"))), refVal_setName );
        setName(refVal_setName);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("domainId"))))
    {
        utility::string_t refVal_setDomainId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("domainId"))), refVal_setDomainId );
        setDomainId(refVal_setDomainId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("description"))))
    {
        utility::string_t refVal_setDescription;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("description"))), refVal_setDescription );
        setDescription(refVal_setDescription);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("emailAddress"))))
    {
        utility::string_t refVal_setEmailAddress;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("emailAddress"))), refVal_setEmailAddress );
        setEmailAddress(refVal_setEmailAddress);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("expiresAt"))))
    {
        utility::string_t refVal_setExpiresAt;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("expiresAt"))), refVal_setExpiresAt );
        setExpiresAt(refVal_setExpiresAt);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("favourite"))))
    {
        bool refVal_setFavourite;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("favourite"))), refVal_setFavourite );
        setFavourite(refVal_setFavourite);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("tags"))))
    {
        std::vector<utility::string_t> refVal_setTags;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("tags"))), refVal_setTags );
        setTags(refVal_setTags);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("inboxType"))))
    {
        utility::string_t refVal_setInboxType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("inboxType"))), refVal_setInboxType );
        setInboxType(refVal_setInboxType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("readOnly"))))
    {
        bool refVal_setReadOnly;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("readOnly"))), refVal_setReadOnly );
        setReadOnly(refVal_setReadOnly);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("virtualInbox"))))
    {
        bool refVal_setVirtualInbox;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("virtualInbox"))), refVal_setVirtualInbox );
        setVirtualInbox(refVal_setVirtualInbox);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("functionsAs"))))
    {
        utility::string_t refVal_setFunctionsAs;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("functionsAs"))), refVal_setFunctionsAs );
        setFunctionsAs(refVal_setFunctionsAs);
    }
    return ok;
}

utility::string_t InboxDto::getId() const
{
    return m_Id;
}

void InboxDto::setId(const utility::string_t& value)
{
    m_Id = value;
    m_IdIsSet = true;
}

bool InboxDto::idIsSet() const
{
    return m_IdIsSet;
}

void InboxDto::unsetId()
{
    m_IdIsSet = false;
}
utility::string_t InboxDto::getUserId() const
{
    return m_UserId;
}

void InboxDto::setUserId(const utility::string_t& value)
{
    m_UserId = value;
    m_UserIdIsSet = true;
}

bool InboxDto::userIdIsSet() const
{
    return m_UserIdIsSet;
}

void InboxDto::unsetUserId()
{
    m_UserIdIsSet = false;
}
utility::datetime InboxDto::getCreatedAt() const
{
    return m_CreatedAt;
}

void InboxDto::setCreatedAt(const utility::datetime& value)
{
    m_CreatedAt = value;
    m_CreatedAtIsSet = true;
}

bool InboxDto::createdAtIsSet() const
{
    return m_CreatedAtIsSet;
}

void InboxDto::unsetCreatedAt()
{
    m_CreatedAtIsSet = false;
}
utility::string_t InboxDto::getName() const
{
    return m_Name;
}

void InboxDto::setName(const utility::string_t& value)
{
    m_Name = value;
    m_NameIsSet = true;
}

bool InboxDto::nameIsSet() const
{
    return m_NameIsSet;
}

void InboxDto::unsetName()
{
    m_NameIsSet = false;
}
utility::string_t InboxDto::getDomainId() const
{
    return m_DomainId;
}

void InboxDto::setDomainId(const utility::string_t& value)
{
    m_DomainId = value;
    m_DomainIdIsSet = true;
}

bool InboxDto::domainIdIsSet() const
{
    return m_DomainIdIsSet;
}

void InboxDto::unsetDomainId()
{
    m_DomainIdIsSet = false;
}
utility::string_t InboxDto::getDescription() const
{
    return m_Description;
}

void InboxDto::setDescription(const utility::string_t& value)
{
    m_Description = value;
    m_DescriptionIsSet = true;
}

bool InboxDto::descriptionIsSet() const
{
    return m_DescriptionIsSet;
}

void InboxDto::unsetDescription()
{
    m_DescriptionIsSet = false;
}
utility::string_t InboxDto::getEmailAddress() const
{
    return m_EmailAddress;
}

void InboxDto::setEmailAddress(const utility::string_t& value)
{
    m_EmailAddress = value;
    m_EmailAddressIsSet = true;
}

bool InboxDto::emailAddressIsSet() const
{
    return m_EmailAddressIsSet;
}

void InboxDto::unsetEmailAddress()
{
    m_EmailAddressIsSet = false;
}
utility::string_t InboxDto::getExpiresAt() const
{
    return m_ExpiresAt;
}

void InboxDto::setExpiresAt(const utility::string_t& value)
{
    m_ExpiresAt = value;
    m_ExpiresAtIsSet = true;
}

bool InboxDto::expiresAtIsSet() const
{
    return m_ExpiresAtIsSet;
}

void InboxDto::unsetExpiresAt()
{
    m_ExpiresAtIsSet = false;
}
bool InboxDto::isFavourite() const
{
    return m_Favourite;
}

void InboxDto::setFavourite(bool value)
{
    m_Favourite = value;
    m_FavouriteIsSet = true;
}

bool InboxDto::favouriteIsSet() const
{
    return m_FavouriteIsSet;
}

void InboxDto::unsetFavourite()
{
    m_FavouriteIsSet = false;
}
std::vector<utility::string_t>& InboxDto::getTags()
{
    return m_Tags;
}

void InboxDto::setTags(const std::vector<utility::string_t>& value)
{
    m_Tags = value;
    m_TagsIsSet = true;
}

bool InboxDto::tagsIsSet() const
{
    return m_TagsIsSet;
}

void InboxDto::unsetTags()
{
    m_TagsIsSet = false;
}
utility::string_t InboxDto::getInboxType() const
{
    return m_InboxType;
}

void InboxDto::setInboxType(const utility::string_t& value)
{
    m_InboxType = value;
    m_InboxTypeIsSet = true;
}

bool InboxDto::inboxTypeIsSet() const
{
    return m_InboxTypeIsSet;
}

void InboxDto::unsetInboxType()
{
    m_InboxTypeIsSet = false;
}
bool InboxDto::isReadOnly() const
{
    return m_ReadOnly;
}

void InboxDto::setReadOnly(bool value)
{
    m_ReadOnly = value;
    m_ReadOnlyIsSet = true;
}

bool InboxDto::readOnlyIsSet() const
{
    return m_ReadOnlyIsSet;
}

void InboxDto::unsetReadOnly()
{
    m_ReadOnlyIsSet = false;
}
bool InboxDto::isVirtualInbox() const
{
    return m_VirtualInbox;
}

void InboxDto::setVirtualInbox(bool value)
{
    m_VirtualInbox = value;
    m_VirtualInboxIsSet = true;
}

bool InboxDto::virtualInboxIsSet() const
{
    return m_VirtualInboxIsSet;
}

void InboxDto::unsetVirtualInbox()
{
    m_VirtualInboxIsSet = false;
}
utility::string_t InboxDto::getFunctionsAs() const
{
    return m_FunctionsAs;
}

void InboxDto::setFunctionsAs(const utility::string_t& value)
{
    m_FunctionsAs = value;
    m_FunctionsAsIsSet = true;
}

bool InboxDto::functionsAsIsSet() const
{
    return m_FunctionsAsIsSet;
}

void InboxDto::unsetFunctionsAs()
{
    m_FunctionsAsIsSet = false;
}
}
}
}
}


