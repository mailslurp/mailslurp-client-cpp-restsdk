/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/WaitForSmsConditions.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



WaitForSmsConditions::WaitForSmsConditions()
{
    m_PhoneNumberId = utility::conversions::to_string_t("");
    m_PhoneNumberIdIsSet = false;
    m_Limit = 0;
    m_LimitIsSet = false;
    m_Count = 0L;
    m_CountIsSet = false;
    m_DelayTimeout = 0L;
    m_DelayTimeoutIsSet = false;
    m_Timeout = 0L;
    m_TimeoutIsSet = false;
    m_UnreadOnly = false;
    m_UnreadOnlyIsSet = false;
    m_CountType = utility::conversions::to_string_t("");
    m_CountTypeIsSet = false;
    m_MatchesIsSet = false;
    m_SortDirection = utility::conversions::to_string_t("");
    m_SortDirectionIsSet = false;
    m_Since = utility::datetime();
    m_SinceIsSet = false;
    m_Before = utility::datetime();
    m_BeforeIsSet = false;
}

WaitForSmsConditions::~WaitForSmsConditions()
{
}

void WaitForSmsConditions::validate()
{
    // TODO: implement validation
}

web::json::value WaitForSmsConditions::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_PhoneNumberIdIsSet)
    {
        val[utility::conversions::to_string_t(U("phoneNumberId"))] = ModelBase::toJson(m_PhoneNumberId);
    }
    if(m_LimitIsSet)
    {
        val[utility::conversions::to_string_t(U("limit"))] = ModelBase::toJson(m_Limit);
    }
    if(m_CountIsSet)
    {
        val[utility::conversions::to_string_t(U("count"))] = ModelBase::toJson(m_Count);
    }
    if(m_DelayTimeoutIsSet)
    {
        val[utility::conversions::to_string_t(U("delayTimeout"))] = ModelBase::toJson(m_DelayTimeout);
    }
    if(m_TimeoutIsSet)
    {
        val[utility::conversions::to_string_t(U("timeout"))] = ModelBase::toJson(m_Timeout);
    }
    if(m_UnreadOnlyIsSet)
    {
        val[utility::conversions::to_string_t(U("unreadOnly"))] = ModelBase::toJson(m_UnreadOnly);
    }
    if(m_CountTypeIsSet)
    {
        val[utility::conversions::to_string_t(U("countType"))] = ModelBase::toJson(m_CountType);
    }
    if(m_MatchesIsSet)
    {
        val[utility::conversions::to_string_t(U("matches"))] = ModelBase::toJson(m_Matches);
    }
    if(m_SortDirectionIsSet)
    {
        val[utility::conversions::to_string_t(U("sortDirection"))] = ModelBase::toJson(m_SortDirection);
    }
    if(m_SinceIsSet)
    {
        val[utility::conversions::to_string_t(U("since"))] = ModelBase::toJson(m_Since);
    }
    if(m_BeforeIsSet)
    {
        val[utility::conversions::to_string_t(U("before"))] = ModelBase::toJson(m_Before);
    }

    return val;
}

bool WaitForSmsConditions::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("phoneNumberId"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("phoneNumberId")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setPhoneNumberId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setPhoneNumberId);
            setPhoneNumberId(refVal_setPhoneNumberId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("limit"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("limit")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setLimit;
            ok &= ModelBase::fromJson(fieldValue, refVal_setLimit);
            setLimit(refVal_setLimit);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("count"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("count")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setCount;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCount);
            setCount(refVal_setCount);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("delayTimeout"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("delayTimeout")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setDelayTimeout;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDelayTimeout);
            setDelayTimeout(refVal_setDelayTimeout);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("timeout"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("timeout")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setTimeout;
            ok &= ModelBase::fromJson(fieldValue, refVal_setTimeout);
            setTimeout(refVal_setTimeout);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("unreadOnly"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("unreadOnly")));
        if(!fieldValue.is_null())
        {
            bool refVal_setUnreadOnly;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUnreadOnly);
            setUnreadOnly(refVal_setUnreadOnly);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("countType"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("countType")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setCountType;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCountType);
            setCountType(refVal_setCountType);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("matches"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("matches")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<SmsMatchOption>> refVal_setMatches;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMatches);
            setMatches(refVal_setMatches);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("sortDirection"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("sortDirection")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setSortDirection;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSortDirection);
            setSortDirection(refVal_setSortDirection);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("since"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("since")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setSince;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSince);
            setSince(refVal_setSince);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("before"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("before")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setBefore;
            ok &= ModelBase::fromJson(fieldValue, refVal_setBefore);
            setBefore(refVal_setBefore);
        }
    }
    return ok;
}

void WaitForSmsConditions::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_PhoneNumberIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("phoneNumberId")), m_PhoneNumberId));
    }
    if(m_LimitIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("limit")), m_Limit));
    }
    if(m_CountIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("count")), m_Count));
    }
    if(m_DelayTimeoutIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("delayTimeout")), m_DelayTimeout));
    }
    if(m_TimeoutIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("timeout")), m_Timeout));
    }
    if(m_UnreadOnlyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("unreadOnly")), m_UnreadOnly));
    }
    if(m_CountTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("countType")), m_CountType));
    }
    if(m_MatchesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("matches")), m_Matches));
    }
    if(m_SortDirectionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("sortDirection")), m_SortDirection));
    }
    if(m_SinceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("since")), m_Since));
    }
    if(m_BeforeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("before")), m_Before));
    }
}

bool WaitForSmsConditions::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("phoneNumberId"))))
    {
        utility::string_t refVal_setPhoneNumberId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("phoneNumberId"))), refVal_setPhoneNumberId );
        setPhoneNumberId(refVal_setPhoneNumberId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("limit"))))
    {
        int32_t refVal_setLimit;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("limit"))), refVal_setLimit );
        setLimit(refVal_setLimit);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("count"))))
    {
        int64_t refVal_setCount;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("count"))), refVal_setCount );
        setCount(refVal_setCount);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("delayTimeout"))))
    {
        int64_t refVal_setDelayTimeout;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("delayTimeout"))), refVal_setDelayTimeout );
        setDelayTimeout(refVal_setDelayTimeout);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("timeout"))))
    {
        int64_t refVal_setTimeout;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("timeout"))), refVal_setTimeout );
        setTimeout(refVal_setTimeout);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("unreadOnly"))))
    {
        bool refVal_setUnreadOnly;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("unreadOnly"))), refVal_setUnreadOnly );
        setUnreadOnly(refVal_setUnreadOnly);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("countType"))))
    {
        utility::string_t refVal_setCountType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("countType"))), refVal_setCountType );
        setCountType(refVal_setCountType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("matches"))))
    {
        std::vector<std::shared_ptr<SmsMatchOption>> refVal_setMatches;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("matches"))), refVal_setMatches );
        setMatches(refVal_setMatches);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("sortDirection"))))
    {
        utility::string_t refVal_setSortDirection;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("sortDirection"))), refVal_setSortDirection );
        setSortDirection(refVal_setSortDirection);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("since"))))
    {
        utility::datetime refVal_setSince;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("since"))), refVal_setSince );
        setSince(refVal_setSince);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("before"))))
    {
        utility::datetime refVal_setBefore;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("before"))), refVal_setBefore );
        setBefore(refVal_setBefore);
    }
    return ok;
}

utility::string_t WaitForSmsConditions::getPhoneNumberId() const
{
    return m_PhoneNumberId;
}

void WaitForSmsConditions::setPhoneNumberId(const utility::string_t& value)
{
    m_PhoneNumberId = value;
    m_PhoneNumberIdIsSet = true;
}

bool WaitForSmsConditions::phoneNumberIdIsSet() const
{
    return m_PhoneNumberIdIsSet;
}

void WaitForSmsConditions::unsetPhoneNumberId()
{
    m_PhoneNumberIdIsSet = false;
}
int32_t WaitForSmsConditions::getLimit() const
{
    return m_Limit;
}

void WaitForSmsConditions::setLimit(int32_t value)
{
    m_Limit = value;
    m_LimitIsSet = true;
}

bool WaitForSmsConditions::limitIsSet() const
{
    return m_LimitIsSet;
}

void WaitForSmsConditions::unsetLimit()
{
    m_LimitIsSet = false;
}
int64_t WaitForSmsConditions::getCount() const
{
    return m_Count;
}

void WaitForSmsConditions::setCount(int64_t value)
{
    m_Count = value;
    m_CountIsSet = true;
}

bool WaitForSmsConditions::countIsSet() const
{
    return m_CountIsSet;
}

void WaitForSmsConditions::unsetCount()
{
    m_CountIsSet = false;
}
int64_t WaitForSmsConditions::getDelayTimeout() const
{
    return m_DelayTimeout;
}

void WaitForSmsConditions::setDelayTimeout(int64_t value)
{
    m_DelayTimeout = value;
    m_DelayTimeoutIsSet = true;
}

bool WaitForSmsConditions::delayTimeoutIsSet() const
{
    return m_DelayTimeoutIsSet;
}

void WaitForSmsConditions::unsetDelayTimeout()
{
    m_DelayTimeoutIsSet = false;
}
int64_t WaitForSmsConditions::getTimeout() const
{
    return m_Timeout;
}

void WaitForSmsConditions::setTimeout(int64_t value)
{
    m_Timeout = value;
    m_TimeoutIsSet = true;
}

bool WaitForSmsConditions::timeoutIsSet() const
{
    return m_TimeoutIsSet;
}

void WaitForSmsConditions::unsetTimeout()
{
    m_TimeoutIsSet = false;
}
bool WaitForSmsConditions::isUnreadOnly() const
{
    return m_UnreadOnly;
}

void WaitForSmsConditions::setUnreadOnly(bool value)
{
    m_UnreadOnly = value;
    m_UnreadOnlyIsSet = true;
}

bool WaitForSmsConditions::unreadOnlyIsSet() const
{
    return m_UnreadOnlyIsSet;
}

void WaitForSmsConditions::unsetUnreadOnly()
{
    m_UnreadOnlyIsSet = false;
}
utility::string_t WaitForSmsConditions::getCountType() const
{
    return m_CountType;
}

void WaitForSmsConditions::setCountType(const utility::string_t& value)
{
    m_CountType = value;
    m_CountTypeIsSet = true;
}

bool WaitForSmsConditions::countTypeIsSet() const
{
    return m_CountTypeIsSet;
}

void WaitForSmsConditions::unsetCountType()
{
    m_CountTypeIsSet = false;
}
std::vector<std::shared_ptr<SmsMatchOption>>& WaitForSmsConditions::getMatches()
{
    return m_Matches;
}

void WaitForSmsConditions::setMatches(const std::vector<std::shared_ptr<SmsMatchOption>>& value)
{
    m_Matches = value;
    m_MatchesIsSet = true;
}

bool WaitForSmsConditions::matchesIsSet() const
{
    return m_MatchesIsSet;
}

void WaitForSmsConditions::unsetMatches()
{
    m_MatchesIsSet = false;
}
utility::string_t WaitForSmsConditions::getSortDirection() const
{
    return m_SortDirection;
}

void WaitForSmsConditions::setSortDirection(const utility::string_t& value)
{
    m_SortDirection = value;
    m_SortDirectionIsSet = true;
}

bool WaitForSmsConditions::sortDirectionIsSet() const
{
    return m_SortDirectionIsSet;
}

void WaitForSmsConditions::unsetSortDirection()
{
    m_SortDirectionIsSet = false;
}
utility::datetime WaitForSmsConditions::getSince() const
{
    return m_Since;
}

void WaitForSmsConditions::setSince(const utility::datetime& value)
{
    m_Since = value;
    m_SinceIsSet = true;
}

bool WaitForSmsConditions::sinceIsSet() const
{
    return m_SinceIsSet;
}

void WaitForSmsConditions::unsetSince()
{
    m_SinceIsSet = false;
}
utility::datetime WaitForSmsConditions::getBefore() const
{
    return m_Before;
}

void WaitForSmsConditions::setBefore(const utility::datetime& value)
{
    m_Before = value;
    m_BeforeIsSet = true;
}

bool WaitForSmsConditions::beforeIsSet() const
{
    return m_BeforeIsSet;
}

void WaitForSmsConditions::unsetBefore()
{
    m_BeforeIsSet = false;
}
}
}
}
}


