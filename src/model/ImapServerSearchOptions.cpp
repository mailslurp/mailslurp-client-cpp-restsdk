/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/ImapServerSearchOptions.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



ImapServerSearchOptions::ImapServerSearchOptions()
{
    m_SeqNum = utility::conversions::to_string_t("");
    m_SeqNumIsSet = false;
    m_Uid = utility::conversions::to_string_t("");
    m_UidIsSet = false;
    m_Since = utility::datetime();
    m_SinceIsSet = false;
    m_Before = utility::datetime();
    m_BeforeIsSet = false;
    m_SentSince = utility::datetime();
    m_SentSinceIsSet = false;
    m_SentBefore = utility::datetime();
    m_SentBeforeIsSet = false;
    m_HeaderIsSet = false;
    m_BodyIsSet = false;
    m_TextIsSet = false;
    m_WithFlagsIsSet = false;
    m_WithoutFlagsIsSet = false;
}

ImapServerSearchOptions::~ImapServerSearchOptions()
{
}

void ImapServerSearchOptions::validate()
{
    // TODO: implement validation
}

web::json::value ImapServerSearchOptions::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_SeqNumIsSet)
    {
        val[utility::conversions::to_string_t(U("seqNum"))] = ModelBase::toJson(m_SeqNum);
    }
    if(m_UidIsSet)
    {
        val[utility::conversions::to_string_t(U("uid"))] = ModelBase::toJson(m_Uid);
    }
    if(m_SinceIsSet)
    {
        val[utility::conversions::to_string_t(U("since"))] = ModelBase::toJson(m_Since);
    }
    if(m_BeforeIsSet)
    {
        val[utility::conversions::to_string_t(U("before"))] = ModelBase::toJson(m_Before);
    }
    if(m_SentSinceIsSet)
    {
        val[utility::conversions::to_string_t(U("sentSince"))] = ModelBase::toJson(m_SentSince);
    }
    if(m_SentBeforeIsSet)
    {
        val[utility::conversions::to_string_t(U("sentBefore"))] = ModelBase::toJson(m_SentBefore);
    }
    if(m_HeaderIsSet)
    {
        val[utility::conversions::to_string_t(U("header"))] = ModelBase::toJson(m_Header);
    }
    if(m_BodyIsSet)
    {
        val[utility::conversions::to_string_t(U("body"))] = ModelBase::toJson(m_Body);
    }
    if(m_TextIsSet)
    {
        val[utility::conversions::to_string_t(U("text"))] = ModelBase::toJson(m_Text);
    }
    if(m_WithFlagsIsSet)
    {
        val[utility::conversions::to_string_t(U("withFlags"))] = ModelBase::toJson(m_WithFlags);
    }
    if(m_WithoutFlagsIsSet)
    {
        val[utility::conversions::to_string_t(U("withoutFlags"))] = ModelBase::toJson(m_WithoutFlags);
    }

    return val;
}

bool ImapServerSearchOptions::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("seqNum"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("seqNum")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setSeqNum;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSeqNum);
            setSeqNum(refVal_setSeqNum);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("uid"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("uid")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setUid;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUid);
            setUid(refVal_setUid);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("since"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("since")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setSince;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSince);
            setSince(refVal_setSince);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("before"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("before")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setBefore;
            ok &= ModelBase::fromJson(fieldValue, refVal_setBefore);
            setBefore(refVal_setBefore);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("sentSince"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("sentSince")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setSentSince;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSentSince);
            setSentSince(refVal_setSentSince);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("sentBefore"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("sentBefore")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setSentBefore;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSentBefore);
            setSentBefore(refVal_setSentBefore);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("header"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("header")));
        if(!fieldValue.is_null())
        {
            std::map<utility::string_t, std::vector<utility::string_t>> refVal_setHeader;
            ok &= ModelBase::fromJson(fieldValue, refVal_setHeader);
            setHeader(refVal_setHeader);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("body"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("body")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setBody;
            ok &= ModelBase::fromJson(fieldValue, refVal_setBody);
            setBody(refVal_setBody);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("text"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("text")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setText;
            ok &= ModelBase::fromJson(fieldValue, refVal_setText);
            setText(refVal_setText);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("withFlags"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("withFlags")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setWithFlags;
            ok &= ModelBase::fromJson(fieldValue, refVal_setWithFlags);
            setWithFlags(refVal_setWithFlags);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("withoutFlags"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("withoutFlags")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setWithoutFlags;
            ok &= ModelBase::fromJson(fieldValue, refVal_setWithoutFlags);
            setWithoutFlags(refVal_setWithoutFlags);
        }
    }
    return ok;
}

void ImapServerSearchOptions::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_SeqNumIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("seqNum")), m_SeqNum));
    }
    if(m_UidIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("uid")), m_Uid));
    }
    if(m_SinceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("since")), m_Since));
    }
    if(m_BeforeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("before")), m_Before));
    }
    if(m_SentSinceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("sentSince")), m_SentSince));
    }
    if(m_SentBeforeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("sentBefore")), m_SentBefore));
    }
    if(m_HeaderIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("header")), m_Header));
    }
    if(m_BodyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("body")), m_Body));
    }
    if(m_TextIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("text")), m_Text));
    }
    if(m_WithFlagsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("withFlags")), m_WithFlags));
    }
    if(m_WithoutFlagsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("withoutFlags")), m_WithoutFlags));
    }
}

bool ImapServerSearchOptions::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("seqNum"))))
    {
        utility::string_t refVal_setSeqNum;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("seqNum"))), refVal_setSeqNum );
        setSeqNum(refVal_setSeqNum);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("uid"))))
    {
        utility::string_t refVal_setUid;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("uid"))), refVal_setUid );
        setUid(refVal_setUid);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("since"))))
    {
        utility::datetime refVal_setSince;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("since"))), refVal_setSince );
        setSince(refVal_setSince);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("before"))))
    {
        utility::datetime refVal_setBefore;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("before"))), refVal_setBefore );
        setBefore(refVal_setBefore);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("sentSince"))))
    {
        utility::datetime refVal_setSentSince;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("sentSince"))), refVal_setSentSince );
        setSentSince(refVal_setSentSince);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("sentBefore"))))
    {
        utility::datetime refVal_setSentBefore;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("sentBefore"))), refVal_setSentBefore );
        setSentBefore(refVal_setSentBefore);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("header"))))
    {
        std::map<utility::string_t, std::vector<utility::string_t>> refVal_setHeader;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("header"))), refVal_setHeader );
        setHeader(refVal_setHeader);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("body"))))
    {
        std::vector<utility::string_t> refVal_setBody;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("body"))), refVal_setBody );
        setBody(refVal_setBody);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("text"))))
    {
        std::vector<utility::string_t> refVal_setText;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("text"))), refVal_setText );
        setText(refVal_setText);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("withFlags"))))
    {
        std::vector<utility::string_t> refVal_setWithFlags;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("withFlags"))), refVal_setWithFlags );
        setWithFlags(refVal_setWithFlags);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("withoutFlags"))))
    {
        std::vector<utility::string_t> refVal_setWithoutFlags;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("withoutFlags"))), refVal_setWithoutFlags );
        setWithoutFlags(refVal_setWithoutFlags);
    }
    return ok;
}

utility::string_t ImapServerSearchOptions::getSeqNum() const
{
    return m_SeqNum;
}

void ImapServerSearchOptions::setSeqNum(const utility::string_t& value)
{
    m_SeqNum = value;
    m_SeqNumIsSet = true;
}

bool ImapServerSearchOptions::seqNumIsSet() const
{
    return m_SeqNumIsSet;
}

void ImapServerSearchOptions::unsetSeqNum()
{
    m_SeqNumIsSet = false;
}
utility::string_t ImapServerSearchOptions::getUid() const
{
    return m_Uid;
}

void ImapServerSearchOptions::setUid(const utility::string_t& value)
{
    m_Uid = value;
    m_UidIsSet = true;
}

bool ImapServerSearchOptions::uidIsSet() const
{
    return m_UidIsSet;
}

void ImapServerSearchOptions::unsetUid()
{
    m_UidIsSet = false;
}
utility::datetime ImapServerSearchOptions::getSince() const
{
    return m_Since;
}

void ImapServerSearchOptions::setSince(const utility::datetime& value)
{
    m_Since = value;
    m_SinceIsSet = true;
}

bool ImapServerSearchOptions::sinceIsSet() const
{
    return m_SinceIsSet;
}

void ImapServerSearchOptions::unsetSince()
{
    m_SinceIsSet = false;
}
utility::datetime ImapServerSearchOptions::getBefore() const
{
    return m_Before;
}

void ImapServerSearchOptions::setBefore(const utility::datetime& value)
{
    m_Before = value;
    m_BeforeIsSet = true;
}

bool ImapServerSearchOptions::beforeIsSet() const
{
    return m_BeforeIsSet;
}

void ImapServerSearchOptions::unsetBefore()
{
    m_BeforeIsSet = false;
}
utility::datetime ImapServerSearchOptions::getSentSince() const
{
    return m_SentSince;
}

void ImapServerSearchOptions::setSentSince(const utility::datetime& value)
{
    m_SentSince = value;
    m_SentSinceIsSet = true;
}

bool ImapServerSearchOptions::sentSinceIsSet() const
{
    return m_SentSinceIsSet;
}

void ImapServerSearchOptions::unsetSentSince()
{
    m_SentSinceIsSet = false;
}
utility::datetime ImapServerSearchOptions::getSentBefore() const
{
    return m_SentBefore;
}

void ImapServerSearchOptions::setSentBefore(const utility::datetime& value)
{
    m_SentBefore = value;
    m_SentBeforeIsSet = true;
}

bool ImapServerSearchOptions::sentBeforeIsSet() const
{
    return m_SentBeforeIsSet;
}

void ImapServerSearchOptions::unsetSentBefore()
{
    m_SentBeforeIsSet = false;
}
std::map<utility::string_t, std::vector<utility::string_t>>& ImapServerSearchOptions::getHeader()
{
    return m_Header;
}

void ImapServerSearchOptions::setHeader(const std::map<utility::string_t, std::vector<utility::string_t>>& value)
{
    m_Header = value;
    m_HeaderIsSet = true;
}

bool ImapServerSearchOptions::headerIsSet() const
{
    return m_HeaderIsSet;
}

void ImapServerSearchOptions::unsetHeader()
{
    m_HeaderIsSet = false;
}
std::vector<utility::string_t>& ImapServerSearchOptions::getBody()
{
    return m_Body;
}

void ImapServerSearchOptions::setBody(const std::vector<utility::string_t>& value)
{
    m_Body = value;
    m_BodyIsSet = true;
}

bool ImapServerSearchOptions::bodyIsSet() const
{
    return m_BodyIsSet;
}

void ImapServerSearchOptions::unsetBody()
{
    m_BodyIsSet = false;
}
std::vector<utility::string_t>& ImapServerSearchOptions::getText()
{
    return m_Text;
}

void ImapServerSearchOptions::setText(const std::vector<utility::string_t>& value)
{
    m_Text = value;
    m_TextIsSet = true;
}

bool ImapServerSearchOptions::textIsSet() const
{
    return m_TextIsSet;
}

void ImapServerSearchOptions::unsetText()
{
    m_TextIsSet = false;
}
std::vector<utility::string_t>& ImapServerSearchOptions::getWithFlags()
{
    return m_WithFlags;
}

void ImapServerSearchOptions::setWithFlags(const std::vector<utility::string_t>& value)
{
    m_WithFlags = value;
    m_WithFlagsIsSet = true;
}

bool ImapServerSearchOptions::withFlagsIsSet() const
{
    return m_WithFlagsIsSet;
}

void ImapServerSearchOptions::unsetWithFlags()
{
    m_WithFlagsIsSet = false;
}
std::vector<utility::string_t>& ImapServerSearchOptions::getWithoutFlags()
{
    return m_WithoutFlags;
}

void ImapServerSearchOptions::setWithoutFlags(const std::vector<utility::string_t>& value)
{
    m_WithoutFlags = value;
    m_WithoutFlagsIsSet = true;
}

bool ImapServerSearchOptions::withoutFlagsIsSet() const
{
    return m_WithoutFlagsIsSet;
}

void ImapServerSearchOptions::unsetWithoutFlags()
{
    m_WithoutFlagsIsSet = false;
}
}
}
}
}


