/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/EmailLinksResult.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



EmailLinksResult::EmailLinksResult()
{
    m_LinksIsSet = false;
    m_Body = utility::conversions::to_string_t("");
    m_BodyIsSet = false;
}

EmailLinksResult::~EmailLinksResult()
{
}

void EmailLinksResult::validate()
{
    // TODO: implement validation
}

web::json::value EmailLinksResult::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_LinksIsSet)
    {
        val[utility::conversions::to_string_t(U("links"))] = ModelBase::toJson(m_Links);
    }
    if(m_BodyIsSet)
    {
        val[utility::conversions::to_string_t(U("body"))] = ModelBase::toJson(m_Body);
    }

    return val;
}

bool EmailLinksResult::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("links"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("links")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setLinks;
            ok &= ModelBase::fromJson(fieldValue, refVal_setLinks);
            setLinks(refVal_setLinks);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("body"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("body")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setBody;
            ok &= ModelBase::fromJson(fieldValue, refVal_setBody);
            setBody(refVal_setBody);
        }
    }
    return ok;
}

void EmailLinksResult::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_LinksIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("links")), m_Links));
    }
    if(m_BodyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("body")), m_Body));
    }
}

bool EmailLinksResult::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("links"))))
    {
        std::vector<utility::string_t> refVal_setLinks;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("links"))), refVal_setLinks );
        setLinks(refVal_setLinks);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("body"))))
    {
        utility::string_t refVal_setBody;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("body"))), refVal_setBody );
        setBody(refVal_setBody);
    }
    return ok;
}

std::vector<utility::string_t>& EmailLinksResult::getLinks()
{
    return m_Links;
}

void EmailLinksResult::setLinks(const std::vector<utility::string_t>& value)
{
    m_Links = value;
    m_LinksIsSet = true;
}

bool EmailLinksResult::linksIsSet() const
{
    return m_LinksIsSet;
}

void EmailLinksResult::unsetLinks()
{
    m_LinksIsSet = false;
}
utility::string_t EmailLinksResult::getBody() const
{
    return m_Body;
}

void EmailLinksResult::setBody(const utility::string_t& value)
{
    m_Body = value;
    m_BodyIsSet = true;
}

bool EmailLinksResult::bodyIsSet() const
{
    return m_BodyIsSet;
}

void EmailLinksResult::unsetBody()
{
    m_BodyIsSet = false;
}
}
}
}
}


