/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/AITransformProjection.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



AITransformProjection::AITransformProjection()
{
    m_CreatedAt = utility::datetime();
    m_CreatedAtIsSet = false;
    m_ConditionsIsSet = false;
    m_InstructionsIsSet = false;
    m_OutputSchemaIsSet = false;
    m_Name = utility::conversions::to_string_t("");
    m_NameIsSet = false;
    m_Id = utility::conversions::to_string_t("");
    m_IdIsSet = false;
}

AITransformProjection::~AITransformProjection()
{
}

void AITransformProjection::validate()
{
    // TODO: implement validation
}

web::json::value AITransformProjection::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_CreatedAtIsSet)
    {
        val[utility::conversions::to_string_t(U("createdAt"))] = ModelBase::toJson(m_CreatedAt);
    }
    if(m_ConditionsIsSet)
    {
        val[utility::conversions::to_string_t(U("conditions"))] = ModelBase::toJson(m_Conditions);
    }
    if(m_InstructionsIsSet)
    {
        val[utility::conversions::to_string_t(U("instructions"))] = ModelBase::toJson(m_Instructions);
    }
    if(m_OutputSchemaIsSet)
    {
        val[utility::conversions::to_string_t(U("outputSchema"))] = ModelBase::toJson(m_OutputSchema);
    }
    if(m_NameIsSet)
    {
        val[utility::conversions::to_string_t(U("name"))] = ModelBase::toJson(m_Name);
    }
    if(m_IdIsSet)
    {
        val[utility::conversions::to_string_t(U("id"))] = ModelBase::toJson(m_Id);
    }

    return val;
}

bool AITransformProjection::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("createdAt"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("createdAt")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setCreatedAt;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCreatedAt);
            setCreatedAt(refVal_setCreatedAt);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("conditions"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("conditions")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setConditions;
            ok &= ModelBase::fromJson(fieldValue, refVal_setConditions);
            setConditions(refVal_setConditions);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("instructions"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("instructions")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setInstructions;
            ok &= ModelBase::fromJson(fieldValue, refVal_setInstructions);
            setInstructions(refVal_setInstructions);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("outputSchema"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("outputSchema")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<StructuredOutputSchema> refVal_setOutputSchema;
            ok &= ModelBase::fromJson(fieldValue, refVal_setOutputSchema);
            setOutputSchema(refVal_setOutputSchema);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("name"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("name")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setName;
            ok &= ModelBase::fromJson(fieldValue, refVal_setName);
            setName(refVal_setName);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("id"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("id")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setId);
            setId(refVal_setId);
        }
    }
    return ok;
}

void AITransformProjection::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_CreatedAtIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("createdAt")), m_CreatedAt));
    }
    if(m_ConditionsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("conditions")), m_Conditions));
    }
    if(m_InstructionsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("instructions")), m_Instructions));
    }
    if(m_OutputSchemaIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("outputSchema")), m_OutputSchema));
    }
    if(m_NameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("name")), m_Name));
    }
    if(m_IdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("id")), m_Id));
    }
}

bool AITransformProjection::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("createdAt"))))
    {
        utility::datetime refVal_setCreatedAt;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("createdAt"))), refVal_setCreatedAt );
        setCreatedAt(refVal_setCreatedAt);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("conditions"))))
    {
        std::vector<utility::string_t> refVal_setConditions;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("conditions"))), refVal_setConditions );
        setConditions(refVal_setConditions);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("instructions"))))
    {
        std::vector<utility::string_t> refVal_setInstructions;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("instructions"))), refVal_setInstructions );
        setInstructions(refVal_setInstructions);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("outputSchema"))))
    {
        std::shared_ptr<StructuredOutputSchema> refVal_setOutputSchema;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("outputSchema"))), refVal_setOutputSchema );
        setOutputSchema(refVal_setOutputSchema);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("name"))))
    {
        utility::string_t refVal_setName;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("name"))), refVal_setName );
        setName(refVal_setName);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("id"))))
    {
        utility::string_t refVal_setId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("id"))), refVal_setId );
        setId(refVal_setId);
    }
    return ok;
}

utility::datetime AITransformProjection::getCreatedAt() const
{
    return m_CreatedAt;
}

void AITransformProjection::setCreatedAt(const utility::datetime& value)
{
    m_CreatedAt = value;
    m_CreatedAtIsSet = true;
}

bool AITransformProjection::createdAtIsSet() const
{
    return m_CreatedAtIsSet;
}

void AITransformProjection::unsetCreatedAt()
{
    m_CreatedAtIsSet = false;
}
std::vector<utility::string_t>& AITransformProjection::getConditions()
{
    return m_Conditions;
}

void AITransformProjection::setConditions(const std::vector<utility::string_t>& value)
{
    m_Conditions = value;
    m_ConditionsIsSet = true;
}

bool AITransformProjection::conditionsIsSet() const
{
    return m_ConditionsIsSet;
}

void AITransformProjection::unsetConditions()
{
    m_ConditionsIsSet = false;
}
std::vector<utility::string_t>& AITransformProjection::getInstructions()
{
    return m_Instructions;
}

void AITransformProjection::setInstructions(const std::vector<utility::string_t>& value)
{
    m_Instructions = value;
    m_InstructionsIsSet = true;
}

bool AITransformProjection::instructionsIsSet() const
{
    return m_InstructionsIsSet;
}

void AITransformProjection::unsetInstructions()
{
    m_InstructionsIsSet = false;
}
std::shared_ptr<StructuredOutputSchema> AITransformProjection::getOutputSchema() const
{
    return m_OutputSchema;
}

void AITransformProjection::setOutputSchema(const std::shared_ptr<StructuredOutputSchema>& value)
{
    m_OutputSchema = value;
    m_OutputSchemaIsSet = true;
}

bool AITransformProjection::outputSchemaIsSet() const
{
    return m_OutputSchemaIsSet;
}

void AITransformProjection::unsetOutputSchema()
{
    m_OutputSchemaIsSet = false;
}
utility::string_t AITransformProjection::getName() const
{
    return m_Name;
}

void AITransformProjection::setName(const utility::string_t& value)
{
    m_Name = value;
    m_NameIsSet = true;
}

bool AITransformProjection::nameIsSet() const
{
    return m_NameIsSet;
}

void AITransformProjection::unsetName()
{
    m_NameIsSet = false;
}
utility::string_t AITransformProjection::getId() const
{
    return m_Id;
}

void AITransformProjection::setId(const utility::string_t& value)
{
    m_Id = value;
    m_IdIsSet = true;
}

bool AITransformProjection::idIsSet() const
{
    return m_IdIsSet;
}

void AITransformProjection::unsetId()
{
    m_IdIsSet = false;
}
}
}
}
}


