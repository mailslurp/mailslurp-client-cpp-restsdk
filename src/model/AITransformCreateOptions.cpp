/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/AITransformCreateOptions.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



AITransformCreateOptions::AITransformCreateOptions()
{
    m_Name = utility::conversions::to_string_t("");
    m_NameIsSet = false;
    m_ConditionsIsSet = false;
    m_InstructionsIsSet = false;
    m_OutputSchemaIsSet = false;
    m_OutputSchemaId = utility::conversions::to_string_t("");
    m_OutputSchemaIdIsSet = false;
    m_ExtractPrompt = utility::conversions::to_string_t("");
    m_ExtractPromptIsSet = false;
}

AITransformCreateOptions::~AITransformCreateOptions()
{
}

void AITransformCreateOptions::validate()
{
    // TODO: implement validation
}

web::json::value AITransformCreateOptions::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_NameIsSet)
    {
        val[utility::conversions::to_string_t(U("name"))] = ModelBase::toJson(m_Name);
    }
    if(m_ConditionsIsSet)
    {
        val[utility::conversions::to_string_t(U("conditions"))] = ModelBase::toJson(m_Conditions);
    }
    if(m_InstructionsIsSet)
    {
        val[utility::conversions::to_string_t(U("instructions"))] = ModelBase::toJson(m_Instructions);
    }
    if(m_OutputSchemaIsSet)
    {
        val[utility::conversions::to_string_t(U("outputSchema"))] = ModelBase::toJson(m_OutputSchema);
    }
    if(m_OutputSchemaIdIsSet)
    {
        val[utility::conversions::to_string_t(U("outputSchemaId"))] = ModelBase::toJson(m_OutputSchemaId);
    }
    if(m_ExtractPromptIsSet)
    {
        val[utility::conversions::to_string_t(U("extractPrompt"))] = ModelBase::toJson(m_ExtractPrompt);
    }

    return val;
}

bool AITransformCreateOptions::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("name"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("name")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setName;
            ok &= ModelBase::fromJson(fieldValue, refVal_setName);
            setName(refVal_setName);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("conditions"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("conditions")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setConditions;
            ok &= ModelBase::fromJson(fieldValue, refVal_setConditions);
            setConditions(refVal_setConditions);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("instructions"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("instructions")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setInstructions;
            ok &= ModelBase::fromJson(fieldValue, refVal_setInstructions);
            setInstructions(refVal_setInstructions);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("outputSchema"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("outputSchema")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<StructuredOutputSchema> refVal_setOutputSchema;
            ok &= ModelBase::fromJson(fieldValue, refVal_setOutputSchema);
            setOutputSchema(refVal_setOutputSchema);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("outputSchemaId"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("outputSchemaId")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setOutputSchemaId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setOutputSchemaId);
            setOutputSchemaId(refVal_setOutputSchemaId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("extractPrompt"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("extractPrompt")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setExtractPrompt;
            ok &= ModelBase::fromJson(fieldValue, refVal_setExtractPrompt);
            setExtractPrompt(refVal_setExtractPrompt);
        }
    }
    return ok;
}

void AITransformCreateOptions::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_NameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("name")), m_Name));
    }
    if(m_ConditionsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("conditions")), m_Conditions));
    }
    if(m_InstructionsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("instructions")), m_Instructions));
    }
    if(m_OutputSchemaIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("outputSchema")), m_OutputSchema));
    }
    if(m_OutputSchemaIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("outputSchemaId")), m_OutputSchemaId));
    }
    if(m_ExtractPromptIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("extractPrompt")), m_ExtractPrompt));
    }
}

bool AITransformCreateOptions::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("name"))))
    {
        utility::string_t refVal_setName;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("name"))), refVal_setName );
        setName(refVal_setName);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("conditions"))))
    {
        std::vector<utility::string_t> refVal_setConditions;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("conditions"))), refVal_setConditions );
        setConditions(refVal_setConditions);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("instructions"))))
    {
        std::vector<utility::string_t> refVal_setInstructions;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("instructions"))), refVal_setInstructions );
        setInstructions(refVal_setInstructions);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("outputSchema"))))
    {
        std::shared_ptr<StructuredOutputSchema> refVal_setOutputSchema;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("outputSchema"))), refVal_setOutputSchema );
        setOutputSchema(refVal_setOutputSchema);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("outputSchemaId"))))
    {
        utility::string_t refVal_setOutputSchemaId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("outputSchemaId"))), refVal_setOutputSchemaId );
        setOutputSchemaId(refVal_setOutputSchemaId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("extractPrompt"))))
    {
        utility::string_t refVal_setExtractPrompt;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("extractPrompt"))), refVal_setExtractPrompt );
        setExtractPrompt(refVal_setExtractPrompt);
    }
    return ok;
}

utility::string_t AITransformCreateOptions::getName() const
{
    return m_Name;
}

void AITransformCreateOptions::setName(const utility::string_t& value)
{
    m_Name = value;
    m_NameIsSet = true;
}

bool AITransformCreateOptions::nameIsSet() const
{
    return m_NameIsSet;
}

void AITransformCreateOptions::unsetName()
{
    m_NameIsSet = false;
}
std::vector<utility::string_t>& AITransformCreateOptions::getConditions()
{
    return m_Conditions;
}

void AITransformCreateOptions::setConditions(const std::vector<utility::string_t>& value)
{
    m_Conditions = value;
    m_ConditionsIsSet = true;
}

bool AITransformCreateOptions::conditionsIsSet() const
{
    return m_ConditionsIsSet;
}

void AITransformCreateOptions::unsetConditions()
{
    m_ConditionsIsSet = false;
}
std::vector<utility::string_t>& AITransformCreateOptions::getInstructions()
{
    return m_Instructions;
}

void AITransformCreateOptions::setInstructions(const std::vector<utility::string_t>& value)
{
    m_Instructions = value;
    m_InstructionsIsSet = true;
}

bool AITransformCreateOptions::instructionsIsSet() const
{
    return m_InstructionsIsSet;
}

void AITransformCreateOptions::unsetInstructions()
{
    m_InstructionsIsSet = false;
}
std::shared_ptr<StructuredOutputSchema> AITransformCreateOptions::getOutputSchema() const
{
    return m_OutputSchema;
}

void AITransformCreateOptions::setOutputSchema(const std::shared_ptr<StructuredOutputSchema>& value)
{
    m_OutputSchema = value;
    m_OutputSchemaIsSet = true;
}

bool AITransformCreateOptions::outputSchemaIsSet() const
{
    return m_OutputSchemaIsSet;
}

void AITransformCreateOptions::unsetOutputSchema()
{
    m_OutputSchemaIsSet = false;
}
utility::string_t AITransformCreateOptions::getOutputSchemaId() const
{
    return m_OutputSchemaId;
}

void AITransformCreateOptions::setOutputSchemaId(const utility::string_t& value)
{
    m_OutputSchemaId = value;
    m_OutputSchemaIdIsSet = true;
}

bool AITransformCreateOptions::outputSchemaIdIsSet() const
{
    return m_OutputSchemaIdIsSet;
}

void AITransformCreateOptions::unsetOutputSchemaId()
{
    m_OutputSchemaIdIsSet = false;
}
utility::string_t AITransformCreateOptions::getExtractPrompt() const
{
    return m_ExtractPrompt;
}

void AITransformCreateOptions::setExtractPrompt(const utility::string_t& value)
{
    m_ExtractPrompt = value;
    m_ExtractPromptIsSet = true;
}

bool AITransformCreateOptions::extractPromptIsSet() const
{
    return m_ExtractPromptIsSet;
}

void AITransformCreateOptions::unsetExtractPrompt()
{
    m_ExtractPromptIsSet = false;
}
}
}
}
}


