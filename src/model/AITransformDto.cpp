/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/AITransformDto.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {



AITransformDto::AITransformDto()
{
    m_Id = utility::conversions::to_string_t("");
    m_IdIsSet = false;
    m_Name = utility::conversions::to_string_t("");
    m_NameIsSet = false;
    m_ConditionsIsSet = false;
    m_InstructionsIsSet = false;
    m_OutputSchemaIsSet = false;
}

AITransformDto::~AITransformDto()
{
}

void AITransformDto::validate()
{
    // TODO: implement validation
}

web::json::value AITransformDto::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_IdIsSet)
    {
        val[utility::conversions::to_string_t(U("id"))] = ModelBase::toJson(m_Id);
    }
    if(m_NameIsSet)
    {
        val[utility::conversions::to_string_t(U("name"))] = ModelBase::toJson(m_Name);
    }
    if(m_ConditionsIsSet)
    {
        val[utility::conversions::to_string_t(U("conditions"))] = ModelBase::toJson(m_Conditions);
    }
    if(m_InstructionsIsSet)
    {
        val[utility::conversions::to_string_t(U("instructions"))] = ModelBase::toJson(m_Instructions);
    }
    if(m_OutputSchemaIsSet)
    {
        val[utility::conversions::to_string_t(U("outputSchema"))] = ModelBase::toJson(m_OutputSchema);
    }

    return val;
}

bool AITransformDto::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("id"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("id")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setId);
            setId(refVal_setId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("name"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("name")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setName;
            ok &= ModelBase::fromJson(fieldValue, refVal_setName);
            setName(refVal_setName);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("conditions"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("conditions")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setConditions;
            ok &= ModelBase::fromJson(fieldValue, refVal_setConditions);
            setConditions(refVal_setConditions);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("instructions"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("instructions")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setInstructions;
            ok &= ModelBase::fromJson(fieldValue, refVal_setInstructions);
            setInstructions(refVal_setInstructions);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("outputSchema"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("outputSchema")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<StructuredOutputSchema> refVal_setOutputSchema;
            ok &= ModelBase::fromJson(fieldValue, refVal_setOutputSchema);
            setOutputSchema(refVal_setOutputSchema);
        }
    }
    return ok;
}

void AITransformDto::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_IdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("id")), m_Id));
    }
    if(m_NameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("name")), m_Name));
    }
    if(m_ConditionsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("conditions")), m_Conditions));
    }
    if(m_InstructionsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("instructions")), m_Instructions));
    }
    if(m_OutputSchemaIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("outputSchema")), m_OutputSchema));
    }
}

bool AITransformDto::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("id"))))
    {
        utility::string_t refVal_setId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("id"))), refVal_setId );
        setId(refVal_setId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("name"))))
    {
        utility::string_t refVal_setName;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("name"))), refVal_setName );
        setName(refVal_setName);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("conditions"))))
    {
        std::vector<utility::string_t> refVal_setConditions;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("conditions"))), refVal_setConditions );
        setConditions(refVal_setConditions);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("instructions"))))
    {
        std::vector<utility::string_t> refVal_setInstructions;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("instructions"))), refVal_setInstructions );
        setInstructions(refVal_setInstructions);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("outputSchema"))))
    {
        std::shared_ptr<StructuredOutputSchema> refVal_setOutputSchema;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("outputSchema"))), refVal_setOutputSchema );
        setOutputSchema(refVal_setOutputSchema);
    }
    return ok;
}

utility::string_t AITransformDto::getId() const
{
    return m_Id;
}

void AITransformDto::setId(const utility::string_t& value)
{
    m_Id = value;
    m_IdIsSet = true;
}

bool AITransformDto::idIsSet() const
{
    return m_IdIsSet;
}

void AITransformDto::unsetId()
{
    m_IdIsSet = false;
}
utility::string_t AITransformDto::getName() const
{
    return m_Name;
}

void AITransformDto::setName(const utility::string_t& value)
{
    m_Name = value;
    m_NameIsSet = true;
}

bool AITransformDto::nameIsSet() const
{
    return m_NameIsSet;
}

void AITransformDto::unsetName()
{
    m_NameIsSet = false;
}
std::vector<utility::string_t>& AITransformDto::getConditions()
{
    return m_Conditions;
}

void AITransformDto::setConditions(const std::vector<utility::string_t>& value)
{
    m_Conditions = value;
    m_ConditionsIsSet = true;
}

bool AITransformDto::conditionsIsSet() const
{
    return m_ConditionsIsSet;
}

void AITransformDto::unsetConditions()
{
    m_ConditionsIsSet = false;
}
std::vector<utility::string_t>& AITransformDto::getInstructions()
{
    return m_Instructions;
}

void AITransformDto::setInstructions(const std::vector<utility::string_t>& value)
{
    m_Instructions = value;
    m_InstructionsIsSet = true;
}

bool AITransformDto::instructionsIsSet() const
{
    return m_InstructionsIsSet;
}

void AITransformDto::unsetInstructions()
{
    m_InstructionsIsSet = false;
}
std::shared_ptr<StructuredOutputSchema> AITransformDto::getOutputSchema() const
{
    return m_OutputSchema;
}

void AITransformDto::setOutputSchema(const std::shared_ptr<StructuredOutputSchema>& value)
{
    m_OutputSchema = value;
    m_OutputSchemaIsSet = true;
}

bool AITransformDto::outputSchemaIsSet() const
{
    return m_OutputSchemaIsSet;
}

void AITransformDto::unsetOutputSchema()
{
    m_OutputSchemaIsSet = false;
}
}
}
}
}


