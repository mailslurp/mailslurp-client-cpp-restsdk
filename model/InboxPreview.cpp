/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "InboxPreview.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {




InboxPreview::InboxPreview()
{
    m_Id = utility::conversions::to_string_t("");
    m_IdIsSet = false;
    m_EmailAddress = utility::conversions::to_string_t("");
    m_EmailAddressIsSet = false;
    m_CreatedAt = utility::datetime();
    m_CreatedAtIsSet = false;
    m_Favourite = false;
    m_FavouriteIsSet = false;
    m_Name = utility::conversions::to_string_t("");
    m_NameIsSet = false;
    m_TagsIsSet = false;
    m_TeamAccess = false;
    m_TeamAccessIsSet = false;
    m_InboxType = utility::conversions::to_string_t("");
    m_InboxTypeIsSet = false;
    m_ExpiresAt = utility::conversions::to_string_t("");
    m_ExpiresAtIsSet = false;
}

InboxPreview::~InboxPreview()
{
}

void InboxPreview::validate()
{
    // TODO: implement validation
}

web::json::value InboxPreview::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_IdIsSet)
    {
        val[utility::conversions::to_string_t("id")] = ModelBase::toJson(m_Id);
    }
    if(m_EmailAddressIsSet)
    {
        val[utility::conversions::to_string_t("emailAddress")] = ModelBase::toJson(m_EmailAddress);
    }
    if(m_CreatedAtIsSet)
    {
        val[utility::conversions::to_string_t("createdAt")] = ModelBase::toJson(m_CreatedAt);
    }
    if(m_FavouriteIsSet)
    {
        val[utility::conversions::to_string_t("favourite")] = ModelBase::toJson(m_Favourite);
    }
    if(m_NameIsSet)
    {
        val[utility::conversions::to_string_t("name")] = ModelBase::toJson(m_Name);
    }
    if(m_TagsIsSet)
    {
        val[utility::conversions::to_string_t("tags")] = ModelBase::toJson(m_Tags);
    }
    if(m_TeamAccessIsSet)
    {
        val[utility::conversions::to_string_t("teamAccess")] = ModelBase::toJson(m_TeamAccess);
    }
    if(m_InboxTypeIsSet)
    {
        val[utility::conversions::to_string_t("inboxType")] = ModelBase::toJson(m_InboxType);
    }
    if(m_ExpiresAtIsSet)
    {
        val[utility::conversions::to_string_t("expiresAt")] = ModelBase::toJson(m_ExpiresAt);
    }

    return val;
}

bool InboxPreview::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t("id")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("id"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_id;
            ok &= ModelBase::fromJson(fieldValue, refVal_id);
            setId(refVal_id);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("emailAddress")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("emailAddress"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_emailAddress;
            ok &= ModelBase::fromJson(fieldValue, refVal_emailAddress);
            setEmailAddress(refVal_emailAddress);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("createdAt")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("createdAt"));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_createdAt;
            ok &= ModelBase::fromJson(fieldValue, refVal_createdAt);
            setCreatedAt(refVal_createdAt);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("favourite")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("favourite"));
        if(!fieldValue.is_null())
        {
            bool refVal_favourite;
            ok &= ModelBase::fromJson(fieldValue, refVal_favourite);
            setFavourite(refVal_favourite);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("name")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("name"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_name;
            ok &= ModelBase::fromJson(fieldValue, refVal_name);
            setName(refVal_name);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("tags")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("tags"));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_tags;
            ok &= ModelBase::fromJson(fieldValue, refVal_tags);
            setTags(refVal_tags);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("teamAccess")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("teamAccess"));
        if(!fieldValue.is_null())
        {
            bool refVal_teamAccess;
            ok &= ModelBase::fromJson(fieldValue, refVal_teamAccess);
            setTeamAccess(refVal_teamAccess);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("inboxType")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("inboxType"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_inboxType;
            ok &= ModelBase::fromJson(fieldValue, refVal_inboxType);
            setInboxType(refVal_inboxType);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("expiresAt")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("expiresAt"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_expiresAt;
            ok &= ModelBase::fromJson(fieldValue, refVal_expiresAt);
            setExpiresAt(refVal_expiresAt);
        }
    }
    return ok;
}

void InboxPreview::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_IdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("id"), m_Id));
    }
    if(m_EmailAddressIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("emailAddress"), m_EmailAddress));
    }
    if(m_CreatedAtIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("createdAt"), m_CreatedAt));
    }
    if(m_FavouriteIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("favourite"), m_Favourite));
    }
    if(m_NameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("name"), m_Name));
    }
    if(m_TagsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("tags"), m_Tags));
    }
    if(m_TeamAccessIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("teamAccess"), m_TeamAccess));
    }
    if(m_InboxTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("inboxType"), m_InboxType));
    }
    if(m_ExpiresAtIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("expiresAt"), m_ExpiresAt));
    }
}

bool InboxPreview::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("id")))
    {
        utility::string_t refVal_id;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("id")), refVal_id );
        setId(refVal_id);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("emailAddress")))
    {
        utility::string_t refVal_emailAddress;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("emailAddress")), refVal_emailAddress );
        setEmailAddress(refVal_emailAddress);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("createdAt")))
    {
        utility::datetime refVal_createdAt;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("createdAt")), refVal_createdAt );
        setCreatedAt(refVal_createdAt);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("favourite")))
    {
        bool refVal_favourite;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("favourite")), refVal_favourite );
        setFavourite(refVal_favourite);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("name")))
    {
        utility::string_t refVal_name;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("name")), refVal_name );
        setName(refVal_name);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("tags")))
    {
        std::vector<utility::string_t> refVal_tags;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("tags")), refVal_tags );
        setTags(refVal_tags);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("teamAccess")))
    {
        bool refVal_teamAccess;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("teamAccess")), refVal_teamAccess );
        setTeamAccess(refVal_teamAccess);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("inboxType")))
    {
        utility::string_t refVal_inboxType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("inboxType")), refVal_inboxType );
        setInboxType(refVal_inboxType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("expiresAt")))
    {
        utility::string_t refVal_expiresAt;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("expiresAt")), refVal_expiresAt );
        setExpiresAt(refVal_expiresAt);
    }
    return ok;
}

utility::string_t InboxPreview::getId() const
{
    return m_Id;
}

void InboxPreview::setId(const utility::string_t& value)
{
    m_Id = value;
    m_IdIsSet = true;
}

bool InboxPreview::idIsSet() const
{
    return m_IdIsSet;
}

void InboxPreview::unsetId()
{
    m_IdIsSet = false;
}
utility::string_t InboxPreview::getEmailAddress() const
{
    return m_EmailAddress;
}

void InboxPreview::setEmailAddress(const utility::string_t& value)
{
    m_EmailAddress = value;
    m_EmailAddressIsSet = true;
}

bool InboxPreview::emailAddressIsSet() const
{
    return m_EmailAddressIsSet;
}

void InboxPreview::unsetEmailAddress()
{
    m_EmailAddressIsSet = false;
}
utility::datetime InboxPreview::getCreatedAt() const
{
    return m_CreatedAt;
}

void InboxPreview::setCreatedAt(const utility::datetime& value)
{
    m_CreatedAt = value;
    m_CreatedAtIsSet = true;
}

bool InboxPreview::createdAtIsSet() const
{
    return m_CreatedAtIsSet;
}

void InboxPreview::unsetCreatedAt()
{
    m_CreatedAtIsSet = false;
}
bool InboxPreview::isFavourite() const
{
    return m_Favourite;
}

void InboxPreview::setFavourite(bool value)
{
    m_Favourite = value;
    m_FavouriteIsSet = true;
}

bool InboxPreview::favouriteIsSet() const
{
    return m_FavouriteIsSet;
}

void InboxPreview::unsetFavourite()
{
    m_FavouriteIsSet = false;
}
utility::string_t InboxPreview::getName() const
{
    return m_Name;
}

void InboxPreview::setName(const utility::string_t& value)
{
    m_Name = value;
    m_NameIsSet = true;
}

bool InboxPreview::nameIsSet() const
{
    return m_NameIsSet;
}

void InboxPreview::unsetName()
{
    m_NameIsSet = false;
}
std::vector<utility::string_t>& InboxPreview::getTags()
{
    return m_Tags;
}

void InboxPreview::setTags(const std::vector<utility::string_t>& value)
{
    m_Tags = value;
    m_TagsIsSet = true;
}

bool InboxPreview::tagsIsSet() const
{
    return m_TagsIsSet;
}

void InboxPreview::unsetTags()
{
    m_TagsIsSet = false;
}
bool InboxPreview::isTeamAccess() const
{
    return m_TeamAccess;
}

void InboxPreview::setTeamAccess(bool value)
{
    m_TeamAccess = value;
    m_TeamAccessIsSet = true;
}

bool InboxPreview::teamAccessIsSet() const
{
    return m_TeamAccessIsSet;
}

void InboxPreview::unsetTeamAccess()
{
    m_TeamAccessIsSet = false;
}
utility::string_t InboxPreview::getInboxType() const
{
    return m_InboxType;
}

void InboxPreview::setInboxType(const utility::string_t& value)
{
    m_InboxType = value;
    m_InboxTypeIsSet = true;
}

bool InboxPreview::inboxTypeIsSet() const
{
    return m_InboxTypeIsSet;
}

void InboxPreview::unsetInboxType()
{
    m_InboxTypeIsSet = false;
}
utility::string_t InboxPreview::getExpiresAt() const
{
    return m_ExpiresAt;
}

void InboxPreview::setExpiresAt(const utility::string_t& value)
{
    m_ExpiresAt = value;
    m_ExpiresAtIsSet = true;
}

bool InboxPreview::expiresAtIsSet() const
{
    return m_ExpiresAtIsSet;
}

void InboxPreview::unsetExpiresAt()
{
    m_ExpiresAtIsSet = false;
}
}
}
}
}


