/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "Pageable.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {




Pageable::Pageable()
{
    m_Offset = 0L;
    m_OffsetIsSet = false;
    m_SortIsSet = false;
    m_Paged = false;
    m_PagedIsSet = false;
    m_Unpaged = false;
    m_UnpagedIsSet = false;
    m_PageNumber = 0;
    m_PageNumberIsSet = false;
    m_PageSize = 0;
    m_PageSizeIsSet = false;
}

Pageable::~Pageable()
{
}

void Pageable::validate()
{
    // TODO: implement validation
}

web::json::value Pageable::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_OffsetIsSet)
    {
        val[utility::conversions::to_string_t("offset")] = ModelBase::toJson(m_Offset);
    }
    if(m_SortIsSet)
    {
        val[utility::conversions::to_string_t("sort")] = ModelBase::toJson(m_Sort);
    }
    if(m_PagedIsSet)
    {
        val[utility::conversions::to_string_t("paged")] = ModelBase::toJson(m_Paged);
    }
    if(m_UnpagedIsSet)
    {
        val[utility::conversions::to_string_t("unpaged")] = ModelBase::toJson(m_Unpaged);
    }
    if(m_PageNumberIsSet)
    {
        val[utility::conversions::to_string_t("pageNumber")] = ModelBase::toJson(m_PageNumber);
    }
    if(m_PageSizeIsSet)
    {
        val[utility::conversions::to_string_t("pageSize")] = ModelBase::toJson(m_PageSize);
    }

    return val;
}

bool Pageable::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t("offset")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("offset"));
        if(!fieldValue.is_null())
        {
            int64_t refVal_offset;
            ok &= ModelBase::fromJson(fieldValue, refVal_offset);
            setOffset(refVal_offset);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("sort")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("sort"));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Sort> refVal_sort;
            ok &= ModelBase::fromJson(fieldValue, refVal_sort);
            setSort(refVal_sort);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("paged")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("paged"));
        if(!fieldValue.is_null())
        {
            bool refVal_paged;
            ok &= ModelBase::fromJson(fieldValue, refVal_paged);
            setPaged(refVal_paged);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("unpaged")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("unpaged"));
        if(!fieldValue.is_null())
        {
            bool refVal_unpaged;
            ok &= ModelBase::fromJson(fieldValue, refVal_unpaged);
            setUnpaged(refVal_unpaged);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("pageNumber")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("pageNumber"));
        if(!fieldValue.is_null())
        {
            int32_t refVal_pageNumber;
            ok &= ModelBase::fromJson(fieldValue, refVal_pageNumber);
            setPageNumber(refVal_pageNumber);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("pageSize")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("pageSize"));
        if(!fieldValue.is_null())
        {
            int32_t refVal_pageSize;
            ok &= ModelBase::fromJson(fieldValue, refVal_pageSize);
            setPageSize(refVal_pageSize);
        }
    }
    return ok;
}

void Pageable::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_OffsetIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("offset"), m_Offset));
    }
    if(m_SortIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("sort"), m_Sort));
    }
    if(m_PagedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("paged"), m_Paged));
    }
    if(m_UnpagedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("unpaged"), m_Unpaged));
    }
    if(m_PageNumberIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("pageNumber"), m_PageNumber));
    }
    if(m_PageSizeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("pageSize"), m_PageSize));
    }
}

bool Pageable::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("offset")))
    {
        int64_t refVal_offset;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("offset")), refVal_offset );
        setOffset(refVal_offset);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("sort")))
    {
        std::shared_ptr<Sort> refVal_sort;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("sort")), refVal_sort );
        setSort(refVal_sort);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("paged")))
    {
        bool refVal_paged;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("paged")), refVal_paged );
        setPaged(refVal_paged);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("unpaged")))
    {
        bool refVal_unpaged;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("unpaged")), refVal_unpaged );
        setUnpaged(refVal_unpaged);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("pageNumber")))
    {
        int32_t refVal_pageNumber;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("pageNumber")), refVal_pageNumber );
        setPageNumber(refVal_pageNumber);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("pageSize")))
    {
        int32_t refVal_pageSize;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("pageSize")), refVal_pageSize );
        setPageSize(refVal_pageSize);
    }
    return ok;
}

int64_t Pageable::getOffset() const
{
    return m_Offset;
}

void Pageable::setOffset(int64_t value)
{
    m_Offset = value;
    m_OffsetIsSet = true;
}

bool Pageable::offsetIsSet() const
{
    return m_OffsetIsSet;
}

void Pageable::unsetOffset()
{
    m_OffsetIsSet = false;
}
std::shared_ptr<Sort> Pageable::getSort() const
{
    return m_Sort;
}

void Pageable::setSort(const std::shared_ptr<Sort>& value)
{
    m_Sort = value;
    m_SortIsSet = true;
}

bool Pageable::sortIsSet() const
{
    return m_SortIsSet;
}

void Pageable::unsetSort()
{
    m_SortIsSet = false;
}
bool Pageable::isPaged() const
{
    return m_Paged;
}

void Pageable::setPaged(bool value)
{
    m_Paged = value;
    m_PagedIsSet = true;
}

bool Pageable::pagedIsSet() const
{
    return m_PagedIsSet;
}

void Pageable::unsetPaged()
{
    m_PagedIsSet = false;
}
bool Pageable::isUnpaged() const
{
    return m_Unpaged;
}

void Pageable::setUnpaged(bool value)
{
    m_Unpaged = value;
    m_UnpagedIsSet = true;
}

bool Pageable::unpagedIsSet() const
{
    return m_UnpagedIsSet;
}

void Pageable::unsetUnpaged()
{
    m_UnpagedIsSet = false;
}
int32_t Pageable::getPageNumber() const
{
    return m_PageNumber;
}

void Pageable::setPageNumber(int32_t value)
{
    m_PageNumber = value;
    m_PageNumberIsSet = true;
}

bool Pageable::pageNumberIsSet() const
{
    return m_PageNumberIsSet;
}

void Pageable::unsetPageNumber()
{
    m_PageNumberIsSet = false;
}
int32_t Pageable::getPageSize() const
{
    return m_PageSize;
}

void Pageable::setPageSize(int32_t value)
{
    m_PageSize = value;
    m_PageSizeIsSet = true;
}

bool Pageable::pageSizeIsSet() const
{
    return m_PageSizeIsSet;
}

void Pageable::unsetPageSize()
{
    m_PageSizeIsSet = false;
}
}
}
}
}


