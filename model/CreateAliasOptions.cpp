/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.   ## Resources - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository 
 *
 * The version of the OpenAPI document: 6.5.2
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CreateAliasOptions.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {




CreateAliasOptions::CreateAliasOptions()
{
    m_EmailAddress = utility::conversions::to_string_t("");
    m_EmailAddressIsSet = false;
    m_InboxId = utility::conversions::to_string_t("");
    m_InboxIdIsSet = false;
    m_Name = utility::conversions::to_string_t("");
    m_NameIsSet = false;
    m_UseThreads = false;
    m_UseThreadsIsSet = false;
}

CreateAliasOptions::~CreateAliasOptions()
{
}

void CreateAliasOptions::validate()
{
    // TODO: implement validation
}

web::json::value CreateAliasOptions::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_EmailAddressIsSet)
    {
        val[utility::conversions::to_string_t("emailAddress")] = ModelBase::toJson(m_EmailAddress);
    }
    if(m_InboxIdIsSet)
    {
        val[utility::conversions::to_string_t("inboxId")] = ModelBase::toJson(m_InboxId);
    }
    if(m_NameIsSet)
    {
        val[utility::conversions::to_string_t("name")] = ModelBase::toJson(m_Name);
    }
    if(m_UseThreadsIsSet)
    {
        val[utility::conversions::to_string_t("useThreads")] = ModelBase::toJson(m_UseThreads);
    }

    return val;
}

bool CreateAliasOptions::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t("emailAddress")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("emailAddress"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_emailAddress;
            ok &= ModelBase::fromJson(fieldValue, refVal_emailAddress);
            setEmailAddress(refVal_emailAddress);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("inboxId")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("inboxId"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_inboxId;
            ok &= ModelBase::fromJson(fieldValue, refVal_inboxId);
            setInboxId(refVal_inboxId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("name")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("name"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_name;
            ok &= ModelBase::fromJson(fieldValue, refVal_name);
            setName(refVal_name);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("useThreads")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("useThreads"));
        if(!fieldValue.is_null())
        {
            bool refVal_useThreads;
            ok &= ModelBase::fromJson(fieldValue, refVal_useThreads);
            setUseThreads(refVal_useThreads);
        }
    }
    return ok;
}

void CreateAliasOptions::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_EmailAddressIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("emailAddress"), m_EmailAddress));
    }
    if(m_InboxIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("inboxId"), m_InboxId));
    }
    if(m_NameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("name"), m_Name));
    }
    if(m_UseThreadsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("useThreads"), m_UseThreads));
    }
}

bool CreateAliasOptions::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("emailAddress")))
    {
        utility::string_t refVal_emailAddress;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("emailAddress")), refVal_emailAddress );
        setEmailAddress(refVal_emailAddress);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("inboxId")))
    {
        utility::string_t refVal_inboxId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("inboxId")), refVal_inboxId );
        setInboxId(refVal_inboxId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("name")))
    {
        utility::string_t refVal_name;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("name")), refVal_name );
        setName(refVal_name);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("useThreads")))
    {
        bool refVal_useThreads;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("useThreads")), refVal_useThreads );
        setUseThreads(refVal_useThreads);
    }
    return ok;
}

utility::string_t CreateAliasOptions::getEmailAddress() const
{
    return m_EmailAddress;
}

void CreateAliasOptions::setEmailAddress(const utility::string_t& value)
{
    m_EmailAddress = value;
    m_EmailAddressIsSet = true;
}

bool CreateAliasOptions::emailAddressIsSet() const
{
    return m_EmailAddressIsSet;
}

void CreateAliasOptions::unsetEmailAddress()
{
    m_EmailAddressIsSet = false;
}
utility::string_t CreateAliasOptions::getInboxId() const
{
    return m_InboxId;
}

void CreateAliasOptions::setInboxId(const utility::string_t& value)
{
    m_InboxId = value;
    m_InboxIdIsSet = true;
}

bool CreateAliasOptions::inboxIdIsSet() const
{
    return m_InboxIdIsSet;
}

void CreateAliasOptions::unsetInboxId()
{
    m_InboxIdIsSet = false;
}
utility::string_t CreateAliasOptions::getName() const
{
    return m_Name;
}

void CreateAliasOptions::setName(const utility::string_t& value)
{
    m_Name = value;
    m_NameIsSet = true;
}

bool CreateAliasOptions::nameIsSet() const
{
    return m_NameIsSet;
}

void CreateAliasOptions::unsetName()
{
    m_NameIsSet = false;
}
bool CreateAliasOptions::isUseThreads() const
{
    return m_UseThreads;
}

void CreateAliasOptions::setUseThreads(bool value)
{
    m_UseThreads = value;
    m_UseThreadsIsSet = true;
}

bool CreateAliasOptions::useThreadsIsSet() const
{
    return m_UseThreadsIsSet;
}

void CreateAliasOptions::unsetUseThreads()
{
    m_UseThreadsIsSet = false;
}
}
}
}
}


