/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.1.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "WaitForConditions.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {




WaitForConditions::WaitForConditions()
{
    m_InboxId = utility::conversions::to_string_t("");
    m_InboxIdIsSet = false;
    m_Count = 0;
    m_CountIsSet = false;
    m_DelayTimeout = 0L;
    m_DelayTimeoutIsSet = false;
    m_Timeout = 0L;
    m_TimeoutIsSet = false;
    m_UnreadOnly = false;
    m_UnreadOnlyIsSet = false;
    m_CountType = utility::conversions::to_string_t("");
    m_CountTypeIsSet = false;
    m_MatchesIsSet = false;
    m_SortDirection = utility::conversions::to_string_t("");
    m_SortDirectionIsSet = false;
    m_Since = utility::datetime();
    m_SinceIsSet = false;
    m_Before = utility::datetime();
    m_BeforeIsSet = false;
}

WaitForConditions::~WaitForConditions()
{
}

void WaitForConditions::validate()
{
    // TODO: implement validation
}

web::json::value WaitForConditions::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_InboxIdIsSet)
    {
        val[utility::conversions::to_string_t("inboxId")] = ModelBase::toJson(m_InboxId);
    }
    if(m_CountIsSet)
    {
        val[utility::conversions::to_string_t("count")] = ModelBase::toJson(m_Count);
    }
    if(m_DelayTimeoutIsSet)
    {
        val[utility::conversions::to_string_t("delayTimeout")] = ModelBase::toJson(m_DelayTimeout);
    }
    if(m_TimeoutIsSet)
    {
        val[utility::conversions::to_string_t("timeout")] = ModelBase::toJson(m_Timeout);
    }
    if(m_UnreadOnlyIsSet)
    {
        val[utility::conversions::to_string_t("unreadOnly")] = ModelBase::toJson(m_UnreadOnly);
    }
    if(m_CountTypeIsSet)
    {
        val[utility::conversions::to_string_t("countType")] = ModelBase::toJson(m_CountType);
    }
    if(m_MatchesIsSet)
    {
        val[utility::conversions::to_string_t("matches")] = ModelBase::toJson(m_Matches);
    }
    if(m_SortDirectionIsSet)
    {
        val[utility::conversions::to_string_t("sortDirection")] = ModelBase::toJson(m_SortDirection);
    }
    if(m_SinceIsSet)
    {
        val[utility::conversions::to_string_t("since")] = ModelBase::toJson(m_Since);
    }
    if(m_BeforeIsSet)
    {
        val[utility::conversions::to_string_t("before")] = ModelBase::toJson(m_Before);
    }

    return val;
}

bool WaitForConditions::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t("inboxId")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("inboxId"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_inboxId;
            ok &= ModelBase::fromJson(fieldValue, refVal_inboxId);
            setInboxId(refVal_inboxId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("count")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("count"));
        if(!fieldValue.is_null())
        {
            int32_t refVal_count;
            ok &= ModelBase::fromJson(fieldValue, refVal_count);
            setCount(refVal_count);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("delayTimeout")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("delayTimeout"));
        if(!fieldValue.is_null())
        {
            int64_t refVal_delayTimeout;
            ok &= ModelBase::fromJson(fieldValue, refVal_delayTimeout);
            setDelayTimeout(refVal_delayTimeout);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("timeout")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("timeout"));
        if(!fieldValue.is_null())
        {
            int64_t refVal_timeout;
            ok &= ModelBase::fromJson(fieldValue, refVal_timeout);
            setTimeout(refVal_timeout);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("unreadOnly")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("unreadOnly"));
        if(!fieldValue.is_null())
        {
            bool refVal_unreadOnly;
            ok &= ModelBase::fromJson(fieldValue, refVal_unreadOnly);
            setUnreadOnly(refVal_unreadOnly);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("countType")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("countType"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_countType;
            ok &= ModelBase::fromJson(fieldValue, refVal_countType);
            setCountType(refVal_countType);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("matches")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("matches"));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<MatchOption>> refVal_matches;
            ok &= ModelBase::fromJson(fieldValue, refVal_matches);
            setMatches(refVal_matches);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("sortDirection")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("sortDirection"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_sortDirection;
            ok &= ModelBase::fromJson(fieldValue, refVal_sortDirection);
            setSortDirection(refVal_sortDirection);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("since")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("since"));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_since;
            ok &= ModelBase::fromJson(fieldValue, refVal_since);
            setSince(refVal_since);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("before")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("before"));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_before;
            ok &= ModelBase::fromJson(fieldValue, refVal_before);
            setBefore(refVal_before);
        }
    }
    return ok;
}

void WaitForConditions::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_InboxIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("inboxId"), m_InboxId));
    }
    if(m_CountIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("count"), m_Count));
    }
    if(m_DelayTimeoutIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("delayTimeout"), m_DelayTimeout));
    }
    if(m_TimeoutIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("timeout"), m_Timeout));
    }
    if(m_UnreadOnlyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("unreadOnly"), m_UnreadOnly));
    }
    if(m_CountTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("countType"), m_CountType));
    }
    if(m_MatchesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("matches"), m_Matches));
    }
    if(m_SortDirectionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("sortDirection"), m_SortDirection));
    }
    if(m_SinceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("since"), m_Since));
    }
    if(m_BeforeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("before"), m_Before));
    }
}

bool WaitForConditions::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("inboxId")))
    {
        utility::string_t refVal_inboxId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("inboxId")), refVal_inboxId );
        setInboxId(refVal_inboxId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("count")))
    {
        int32_t refVal_count;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("count")), refVal_count );
        setCount(refVal_count);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("delayTimeout")))
    {
        int64_t refVal_delayTimeout;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("delayTimeout")), refVal_delayTimeout );
        setDelayTimeout(refVal_delayTimeout);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("timeout")))
    {
        int64_t refVal_timeout;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("timeout")), refVal_timeout );
        setTimeout(refVal_timeout);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("unreadOnly")))
    {
        bool refVal_unreadOnly;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("unreadOnly")), refVal_unreadOnly );
        setUnreadOnly(refVal_unreadOnly);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("countType")))
    {
        utility::string_t refVal_countType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("countType")), refVal_countType );
        setCountType(refVal_countType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("matches")))
    {
        std::vector<std::shared_ptr<MatchOption>> refVal_matches;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("matches")), refVal_matches );
        setMatches(refVal_matches);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("sortDirection")))
    {
        utility::string_t refVal_sortDirection;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("sortDirection")), refVal_sortDirection );
        setSortDirection(refVal_sortDirection);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("since")))
    {
        utility::datetime refVal_since;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("since")), refVal_since );
        setSince(refVal_since);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("before")))
    {
        utility::datetime refVal_before;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("before")), refVal_before );
        setBefore(refVal_before);
    }
    return ok;
}

utility::string_t WaitForConditions::getInboxId() const
{
    return m_InboxId;
}

void WaitForConditions::setInboxId(const utility::string_t& value)
{
    m_InboxId = value;
    m_InboxIdIsSet = true;
}

bool WaitForConditions::inboxIdIsSet() const
{
    return m_InboxIdIsSet;
}

void WaitForConditions::unsetInboxId()
{
    m_InboxIdIsSet = false;
}
int32_t WaitForConditions::getCount() const
{
    return m_Count;
}

void WaitForConditions::setCount(int32_t value)
{
    m_Count = value;
    m_CountIsSet = true;
}

bool WaitForConditions::countIsSet() const
{
    return m_CountIsSet;
}

void WaitForConditions::unsetCount()
{
    m_CountIsSet = false;
}
int64_t WaitForConditions::getDelayTimeout() const
{
    return m_DelayTimeout;
}

void WaitForConditions::setDelayTimeout(int64_t value)
{
    m_DelayTimeout = value;
    m_DelayTimeoutIsSet = true;
}

bool WaitForConditions::delayTimeoutIsSet() const
{
    return m_DelayTimeoutIsSet;
}

void WaitForConditions::unsetDelayTimeout()
{
    m_DelayTimeoutIsSet = false;
}
int64_t WaitForConditions::getTimeout() const
{
    return m_Timeout;
}

void WaitForConditions::setTimeout(int64_t value)
{
    m_Timeout = value;
    m_TimeoutIsSet = true;
}

bool WaitForConditions::timeoutIsSet() const
{
    return m_TimeoutIsSet;
}

void WaitForConditions::unsetTimeout()
{
    m_TimeoutIsSet = false;
}
bool WaitForConditions::isUnreadOnly() const
{
    return m_UnreadOnly;
}

void WaitForConditions::setUnreadOnly(bool value)
{
    m_UnreadOnly = value;
    m_UnreadOnlyIsSet = true;
}

bool WaitForConditions::unreadOnlyIsSet() const
{
    return m_UnreadOnlyIsSet;
}

void WaitForConditions::unsetUnreadOnly()
{
    m_UnreadOnlyIsSet = false;
}
utility::string_t WaitForConditions::getCountType() const
{
    return m_CountType;
}

void WaitForConditions::setCountType(const utility::string_t& value)
{
    m_CountType = value;
    m_CountTypeIsSet = true;
}

bool WaitForConditions::countTypeIsSet() const
{
    return m_CountTypeIsSet;
}

void WaitForConditions::unsetCountType()
{
    m_CountTypeIsSet = false;
}
std::vector<std::shared_ptr<MatchOption>>& WaitForConditions::getMatches()
{
    return m_Matches;
}

void WaitForConditions::setMatches(const std::vector<std::shared_ptr<MatchOption>>& value)
{
    m_Matches = value;
    m_MatchesIsSet = true;
}

bool WaitForConditions::matchesIsSet() const
{
    return m_MatchesIsSet;
}

void WaitForConditions::unsetMatches()
{
    m_MatchesIsSet = false;
}
utility::string_t WaitForConditions::getSortDirection() const
{
    return m_SortDirection;
}

void WaitForConditions::setSortDirection(const utility::string_t& value)
{
    m_SortDirection = value;
    m_SortDirectionIsSet = true;
}

bool WaitForConditions::sortDirectionIsSet() const
{
    return m_SortDirectionIsSet;
}

void WaitForConditions::unsetSortDirection()
{
    m_SortDirectionIsSet = false;
}
utility::datetime WaitForConditions::getSince() const
{
    return m_Since;
}

void WaitForConditions::setSince(const utility::datetime& value)
{
    m_Since = value;
    m_SinceIsSet = true;
}

bool WaitForConditions::sinceIsSet() const
{
    return m_SinceIsSet;
}

void WaitForConditions::unsetSince()
{
    m_SinceIsSet = false;
}
utility::datetime WaitForConditions::getBefore() const
{
    return m_Before;
}

void WaitForConditions::setBefore(const utility::datetime& value)
{
    m_Before = value;
    m_BeforeIsSet = true;
}

bool WaitForConditions::beforeIsSet() const
{
    return m_BeforeIsSet;
}

void WaitForConditions::unsetBefore()
{
    m_BeforeIsSet = false;
}
}
}
}
}


