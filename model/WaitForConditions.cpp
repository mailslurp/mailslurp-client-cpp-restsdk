/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository 
 *
 * The version of the OpenAPI document: 6.5.2
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "WaitForConditions.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {




WaitForConditions::WaitForConditions()
{
    m_Count = 0;
    m_CountIsSet = false;
    m_CountType = utility::conversions::to_string_t("");
    m_CountTypeIsSet = false;
    m_InboxId = utility::conversions::to_string_t("");
    m_InboxIdIsSet = false;
    m_MatchesIsSet = false;
    m_SortDirection = utility::conversions::to_string_t("");
    m_SortDirectionIsSet = false;
    m_Timeout = 0L;
    m_TimeoutIsSet = false;
    m_UnreadOnly = false;
    m_UnreadOnlyIsSet = false;
}

WaitForConditions::~WaitForConditions()
{
}

void WaitForConditions::validate()
{
    // TODO: implement validation
}

web::json::value WaitForConditions::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_CountIsSet)
    {
        val[utility::conversions::to_string_t("count")] = ModelBase::toJson(m_Count);
    }
    if(m_CountTypeIsSet)
    {
        val[utility::conversions::to_string_t("countType")] = ModelBase::toJson(m_CountType);
    }
    if(m_InboxIdIsSet)
    {
        val[utility::conversions::to_string_t("inboxId")] = ModelBase::toJson(m_InboxId);
    }
    if(m_MatchesIsSet)
    {
        val[utility::conversions::to_string_t("matches")] = ModelBase::toJson(m_Matches);
    }
    if(m_SortDirectionIsSet)
    {
        val[utility::conversions::to_string_t("sortDirection")] = ModelBase::toJson(m_SortDirection);
    }
    if(m_TimeoutIsSet)
    {
        val[utility::conversions::to_string_t("timeout")] = ModelBase::toJson(m_Timeout);
    }
    if(m_UnreadOnlyIsSet)
    {
        val[utility::conversions::to_string_t("unreadOnly")] = ModelBase::toJson(m_UnreadOnly);
    }

    return val;
}

bool WaitForConditions::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t("count")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("count"));
        if(!fieldValue.is_null())
        {
            int32_t refVal_count;
            ok &= ModelBase::fromJson(fieldValue, refVal_count);
            setCount(refVal_count);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("countType")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("countType"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_countType;
            ok &= ModelBase::fromJson(fieldValue, refVal_countType);
            setCountType(refVal_countType);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("inboxId")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("inboxId"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_inboxId;
            ok &= ModelBase::fromJson(fieldValue, refVal_inboxId);
            setInboxId(refVal_inboxId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("matches")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("matches"));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<MatchOption>> refVal_matches;
            ok &= ModelBase::fromJson(fieldValue, refVal_matches);
            setMatches(refVal_matches);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("sortDirection")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("sortDirection"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_sortDirection;
            ok &= ModelBase::fromJson(fieldValue, refVal_sortDirection);
            setSortDirection(refVal_sortDirection);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("timeout")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("timeout"));
        if(!fieldValue.is_null())
        {
            int64_t refVal_timeout;
            ok &= ModelBase::fromJson(fieldValue, refVal_timeout);
            setTimeout(refVal_timeout);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("unreadOnly")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("unreadOnly"));
        if(!fieldValue.is_null())
        {
            bool refVal_unreadOnly;
            ok &= ModelBase::fromJson(fieldValue, refVal_unreadOnly);
            setUnreadOnly(refVal_unreadOnly);
        }
    }
    return ok;
}

void WaitForConditions::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_CountIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("count"), m_Count));
    }
    if(m_CountTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("countType"), m_CountType));
    }
    if(m_InboxIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("inboxId"), m_InboxId));
    }
    if(m_MatchesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("matches"), m_Matches));
    }
    if(m_SortDirectionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("sortDirection"), m_SortDirection));
    }
    if(m_TimeoutIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("timeout"), m_Timeout));
    }
    if(m_UnreadOnlyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("unreadOnly"), m_UnreadOnly));
    }
}

bool WaitForConditions::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("count")))
    {
        int32_t refVal_count;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("count")), refVal_count );
        setCount(refVal_count);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("countType")))
    {
        utility::string_t refVal_countType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("countType")), refVal_countType );
        setCountType(refVal_countType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("inboxId")))
    {
        utility::string_t refVal_inboxId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("inboxId")), refVal_inboxId );
        setInboxId(refVal_inboxId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("matches")))
    {
        std::vector<std::shared_ptr<MatchOption>> refVal_matches;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("matches")), refVal_matches );
        setMatches(refVal_matches);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("sortDirection")))
    {
        utility::string_t refVal_sortDirection;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("sortDirection")), refVal_sortDirection );
        setSortDirection(refVal_sortDirection);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("timeout")))
    {
        int64_t refVal_timeout;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("timeout")), refVal_timeout );
        setTimeout(refVal_timeout);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("unreadOnly")))
    {
        bool refVal_unreadOnly;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("unreadOnly")), refVal_unreadOnly );
        setUnreadOnly(refVal_unreadOnly);
    }
    return ok;
}

int32_t WaitForConditions::getCount() const
{
    return m_Count;
}

void WaitForConditions::setCount(int32_t value)
{
    m_Count = value;
    m_CountIsSet = true;
}

bool WaitForConditions::countIsSet() const
{
    return m_CountIsSet;
}

void WaitForConditions::unsetCount()
{
    m_CountIsSet = false;
}
utility::string_t WaitForConditions::getCountType() const
{
    return m_CountType;
}

void WaitForConditions::setCountType(const utility::string_t& value)
{
    m_CountType = value;
    m_CountTypeIsSet = true;
}

bool WaitForConditions::countTypeIsSet() const
{
    return m_CountTypeIsSet;
}

void WaitForConditions::unsetCountType()
{
    m_CountTypeIsSet = false;
}
utility::string_t WaitForConditions::getInboxId() const
{
    return m_InboxId;
}

void WaitForConditions::setInboxId(const utility::string_t& value)
{
    m_InboxId = value;
    m_InboxIdIsSet = true;
}

bool WaitForConditions::inboxIdIsSet() const
{
    return m_InboxIdIsSet;
}

void WaitForConditions::unsetInboxId()
{
    m_InboxIdIsSet = false;
}
std::vector<std::shared_ptr<MatchOption>>& WaitForConditions::getMatches()
{
    return m_Matches;
}

void WaitForConditions::setMatches(const std::vector<std::shared_ptr<MatchOption>>& value)
{
    m_Matches = value;
    m_MatchesIsSet = true;
}

bool WaitForConditions::matchesIsSet() const
{
    return m_MatchesIsSet;
}

void WaitForConditions::unsetMatches()
{
    m_MatchesIsSet = false;
}
utility::string_t WaitForConditions::getSortDirection() const
{
    return m_SortDirection;
}

void WaitForConditions::setSortDirection(const utility::string_t& value)
{
    m_SortDirection = value;
    m_SortDirectionIsSet = true;
}

bool WaitForConditions::sortDirectionIsSet() const
{
    return m_SortDirectionIsSet;
}

void WaitForConditions::unsetSortDirection()
{
    m_SortDirectionIsSet = false;
}
int64_t WaitForConditions::getTimeout() const
{
    return m_Timeout;
}

void WaitForConditions::setTimeout(int64_t value)
{
    m_Timeout = value;
    m_TimeoutIsSet = true;
}

bool WaitForConditions::timeoutIsSet() const
{
    return m_TimeoutIsSet;
}

void WaitForConditions::unsetTimeout()
{
    m_TimeoutIsSet = false;
}
bool WaitForConditions::isUnreadOnly() const
{
    return m_UnreadOnly;
}

void WaitForConditions::setUnreadOnly(bool value)
{
    m_UnreadOnly = value;
    m_UnreadOnlyIsSet = true;
}

bool WaitForConditions::unreadOnlyIsSet() const
{
    return m_UnreadOnlyIsSet;
}

void WaitForConditions::unsetUnreadOnly()
{
    m_UnreadOnlyIsSet = false;
}
}
}
}
}


