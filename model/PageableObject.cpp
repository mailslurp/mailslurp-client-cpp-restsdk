/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "PageableObject.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {




PageableObject::PageableObject()
{
    m_Offset = 0L;
    m_OffsetIsSet = false;
    m_SortIsSet = false;
    m_PageNumber = 0;
    m_PageNumberIsSet = false;
    m_PageSize = 0;
    m_PageSizeIsSet = false;
    m_Paged = false;
    m_PagedIsSet = false;
    m_Unpaged = false;
    m_UnpagedIsSet = false;
}

PageableObject::~PageableObject()
{
}

void PageableObject::validate()
{
    // TODO: implement validation
}

web::json::value PageableObject::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_OffsetIsSet)
    {
        val[utility::conversions::to_string_t("offset")] = ModelBase::toJson(m_Offset);
    }
    if(m_SortIsSet)
    {
        val[utility::conversions::to_string_t("sort")] = ModelBase::toJson(m_Sort);
    }
    if(m_PageNumberIsSet)
    {
        val[utility::conversions::to_string_t("pageNumber")] = ModelBase::toJson(m_PageNumber);
    }
    if(m_PageSizeIsSet)
    {
        val[utility::conversions::to_string_t("pageSize")] = ModelBase::toJson(m_PageSize);
    }
    if(m_PagedIsSet)
    {
        val[utility::conversions::to_string_t("paged")] = ModelBase::toJson(m_Paged);
    }
    if(m_UnpagedIsSet)
    {
        val[utility::conversions::to_string_t("unpaged")] = ModelBase::toJson(m_Unpaged);
    }

    return val;
}

bool PageableObject::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t("offset")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("offset"));
        if(!fieldValue.is_null())
        {
            int64_t refVal_offset;
            ok &= ModelBase::fromJson(fieldValue, refVal_offset);
            setOffset(refVal_offset);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("sort")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("sort"));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Sort> refVal_sort;
            ok &= ModelBase::fromJson(fieldValue, refVal_sort);
            setSort(refVal_sort);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("pageNumber")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("pageNumber"));
        if(!fieldValue.is_null())
        {
            int32_t refVal_pageNumber;
            ok &= ModelBase::fromJson(fieldValue, refVal_pageNumber);
            setPageNumber(refVal_pageNumber);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("pageSize")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("pageSize"));
        if(!fieldValue.is_null())
        {
            int32_t refVal_pageSize;
            ok &= ModelBase::fromJson(fieldValue, refVal_pageSize);
            setPageSize(refVal_pageSize);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("paged")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("paged"));
        if(!fieldValue.is_null())
        {
            bool refVal_paged;
            ok &= ModelBase::fromJson(fieldValue, refVal_paged);
            setPaged(refVal_paged);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("unpaged")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("unpaged"));
        if(!fieldValue.is_null())
        {
            bool refVal_unpaged;
            ok &= ModelBase::fromJson(fieldValue, refVal_unpaged);
            setUnpaged(refVal_unpaged);
        }
    }
    return ok;
}

void PageableObject::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_OffsetIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("offset"), m_Offset));
    }
    if(m_SortIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("sort"), m_Sort));
    }
    if(m_PageNumberIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("pageNumber"), m_PageNumber));
    }
    if(m_PageSizeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("pageSize"), m_PageSize));
    }
    if(m_PagedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("paged"), m_Paged));
    }
    if(m_UnpagedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("unpaged"), m_Unpaged));
    }
}

bool PageableObject::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("offset")))
    {
        int64_t refVal_offset;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("offset")), refVal_offset );
        setOffset(refVal_offset);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("sort")))
    {
        std::shared_ptr<Sort> refVal_sort;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("sort")), refVal_sort );
        setSort(refVal_sort);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("pageNumber")))
    {
        int32_t refVal_pageNumber;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("pageNumber")), refVal_pageNumber );
        setPageNumber(refVal_pageNumber);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("pageSize")))
    {
        int32_t refVal_pageSize;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("pageSize")), refVal_pageSize );
        setPageSize(refVal_pageSize);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("paged")))
    {
        bool refVal_paged;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("paged")), refVal_paged );
        setPaged(refVal_paged);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("unpaged")))
    {
        bool refVal_unpaged;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("unpaged")), refVal_unpaged );
        setUnpaged(refVal_unpaged);
    }
    return ok;
}

int64_t PageableObject::getOffset() const
{
    return m_Offset;
}

void PageableObject::setOffset(int64_t value)
{
    m_Offset = value;
    m_OffsetIsSet = true;
}

bool PageableObject::offsetIsSet() const
{
    return m_OffsetIsSet;
}

void PageableObject::unsetOffset()
{
    m_OffsetIsSet = false;
}
std::shared_ptr<Sort> PageableObject::getSort() const
{
    return m_Sort;
}

void PageableObject::setSort(const std::shared_ptr<Sort>& value)
{
    m_Sort = value;
    m_SortIsSet = true;
}

bool PageableObject::sortIsSet() const
{
    return m_SortIsSet;
}

void PageableObject::unsetSort()
{
    m_SortIsSet = false;
}
int32_t PageableObject::getPageNumber() const
{
    return m_PageNumber;
}

void PageableObject::setPageNumber(int32_t value)
{
    m_PageNumber = value;
    m_PageNumberIsSet = true;
}

bool PageableObject::pageNumberIsSet() const
{
    return m_PageNumberIsSet;
}

void PageableObject::unsetPageNumber()
{
    m_PageNumberIsSet = false;
}
int32_t PageableObject::getPageSize() const
{
    return m_PageSize;
}

void PageableObject::setPageSize(int32_t value)
{
    m_PageSize = value;
    m_PageSizeIsSet = true;
}

bool PageableObject::pageSizeIsSet() const
{
    return m_PageSizeIsSet;
}

void PageableObject::unsetPageSize()
{
    m_PageSizeIsSet = false;
}
bool PageableObject::isPaged() const
{
    return m_Paged;
}

void PageableObject::setPaged(bool value)
{
    m_Paged = value;
    m_PagedIsSet = true;
}

bool PageableObject::pagedIsSet() const
{
    return m_PagedIsSet;
}

void PageableObject::unsetPaged()
{
    m_PagedIsSet = false;
}
bool PageableObject::isUnpaged() const
{
    return m_Unpaged;
}

void PageableObject::setUnpaged(bool value)
{
    m_Unpaged = value;
    m_UnpagedIsSet = true;
}

bool PageableObject::unpagedIsSet() const
{
    return m_UnpagedIsSet;
}

void PageableObject::unsetUnpaged()
{
    m_UnpagedIsSet = false;
}
}
}
}
}


