/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "WaitForSmsConditions.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {




WaitForSmsConditions::WaitForSmsConditions()
{
    m_PhoneNumberId = utility::conversions::to_string_t("");
    m_PhoneNumberIdIsSet = false;
    m_Limit = 0;
    m_LimitIsSet = false;
    m_Count = 0L;
    m_CountIsSet = false;
    m_DelayTimeout = 0L;
    m_DelayTimeoutIsSet = false;
    m_Timeout = 0L;
    m_TimeoutIsSet = false;
    m_UnreadOnly = false;
    m_UnreadOnlyIsSet = false;
    m_CountType = utility::conversions::to_string_t("");
    m_CountTypeIsSet = false;
    m_MatchesIsSet = false;
    m_SortDirection = utility::conversions::to_string_t("");
    m_SortDirectionIsSet = false;
    m_Since = utility::datetime();
    m_SinceIsSet = false;
    m_Before = utility::datetime();
    m_BeforeIsSet = false;
}

WaitForSmsConditions::~WaitForSmsConditions()
{
}

void WaitForSmsConditions::validate()
{
    // TODO: implement validation
}

web::json::value WaitForSmsConditions::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_PhoneNumberIdIsSet)
    {
        val[utility::conversions::to_string_t("phoneNumberId")] = ModelBase::toJson(m_PhoneNumberId);
    }
    if(m_LimitIsSet)
    {
        val[utility::conversions::to_string_t("limit")] = ModelBase::toJson(m_Limit);
    }
    if(m_CountIsSet)
    {
        val[utility::conversions::to_string_t("count")] = ModelBase::toJson(m_Count);
    }
    if(m_DelayTimeoutIsSet)
    {
        val[utility::conversions::to_string_t("delayTimeout")] = ModelBase::toJson(m_DelayTimeout);
    }
    if(m_TimeoutIsSet)
    {
        val[utility::conversions::to_string_t("timeout")] = ModelBase::toJson(m_Timeout);
    }
    if(m_UnreadOnlyIsSet)
    {
        val[utility::conversions::to_string_t("unreadOnly")] = ModelBase::toJson(m_UnreadOnly);
    }
    if(m_CountTypeIsSet)
    {
        val[utility::conversions::to_string_t("countType")] = ModelBase::toJson(m_CountType);
    }
    if(m_MatchesIsSet)
    {
        val[utility::conversions::to_string_t("matches")] = ModelBase::toJson(m_Matches);
    }
    if(m_SortDirectionIsSet)
    {
        val[utility::conversions::to_string_t("sortDirection")] = ModelBase::toJson(m_SortDirection);
    }
    if(m_SinceIsSet)
    {
        val[utility::conversions::to_string_t("since")] = ModelBase::toJson(m_Since);
    }
    if(m_BeforeIsSet)
    {
        val[utility::conversions::to_string_t("before")] = ModelBase::toJson(m_Before);
    }

    return val;
}

bool WaitForSmsConditions::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t("phoneNumberId")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("phoneNumberId"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_phoneNumberId;
            ok &= ModelBase::fromJson(fieldValue, refVal_phoneNumberId);
            setPhoneNumberId(refVal_phoneNumberId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("limit")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("limit"));
        if(!fieldValue.is_null())
        {
            int32_t refVal_limit;
            ok &= ModelBase::fromJson(fieldValue, refVal_limit);
            setLimit(refVal_limit);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("count")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("count"));
        if(!fieldValue.is_null())
        {
            int64_t refVal_count;
            ok &= ModelBase::fromJson(fieldValue, refVal_count);
            setCount(refVal_count);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("delayTimeout")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("delayTimeout"));
        if(!fieldValue.is_null())
        {
            int64_t refVal_delayTimeout;
            ok &= ModelBase::fromJson(fieldValue, refVal_delayTimeout);
            setDelayTimeout(refVal_delayTimeout);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("timeout")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("timeout"));
        if(!fieldValue.is_null())
        {
            int64_t refVal_timeout;
            ok &= ModelBase::fromJson(fieldValue, refVal_timeout);
            setTimeout(refVal_timeout);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("unreadOnly")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("unreadOnly"));
        if(!fieldValue.is_null())
        {
            bool refVal_unreadOnly;
            ok &= ModelBase::fromJson(fieldValue, refVal_unreadOnly);
            setUnreadOnly(refVal_unreadOnly);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("countType")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("countType"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_countType;
            ok &= ModelBase::fromJson(fieldValue, refVal_countType);
            setCountType(refVal_countType);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("matches")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("matches"));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<SmsMatchOption>> refVal_matches;
            ok &= ModelBase::fromJson(fieldValue, refVal_matches);
            setMatches(refVal_matches);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("sortDirection")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("sortDirection"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_sortDirection;
            ok &= ModelBase::fromJson(fieldValue, refVal_sortDirection);
            setSortDirection(refVal_sortDirection);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("since")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("since"));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_since;
            ok &= ModelBase::fromJson(fieldValue, refVal_since);
            setSince(refVal_since);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("before")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("before"));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_before;
            ok &= ModelBase::fromJson(fieldValue, refVal_before);
            setBefore(refVal_before);
        }
    }
    return ok;
}

void WaitForSmsConditions::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_PhoneNumberIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("phoneNumberId"), m_PhoneNumberId));
    }
    if(m_LimitIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("limit"), m_Limit));
    }
    if(m_CountIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("count"), m_Count));
    }
    if(m_DelayTimeoutIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("delayTimeout"), m_DelayTimeout));
    }
    if(m_TimeoutIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("timeout"), m_Timeout));
    }
    if(m_UnreadOnlyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("unreadOnly"), m_UnreadOnly));
    }
    if(m_CountTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("countType"), m_CountType));
    }
    if(m_MatchesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("matches"), m_Matches));
    }
    if(m_SortDirectionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("sortDirection"), m_SortDirection));
    }
    if(m_SinceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("since"), m_Since));
    }
    if(m_BeforeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("before"), m_Before));
    }
}

bool WaitForSmsConditions::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("phoneNumberId")))
    {
        utility::string_t refVal_phoneNumberId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("phoneNumberId")), refVal_phoneNumberId );
        setPhoneNumberId(refVal_phoneNumberId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("limit")))
    {
        int32_t refVal_limit;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("limit")), refVal_limit );
        setLimit(refVal_limit);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("count")))
    {
        int64_t refVal_count;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("count")), refVal_count );
        setCount(refVal_count);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("delayTimeout")))
    {
        int64_t refVal_delayTimeout;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("delayTimeout")), refVal_delayTimeout );
        setDelayTimeout(refVal_delayTimeout);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("timeout")))
    {
        int64_t refVal_timeout;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("timeout")), refVal_timeout );
        setTimeout(refVal_timeout);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("unreadOnly")))
    {
        bool refVal_unreadOnly;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("unreadOnly")), refVal_unreadOnly );
        setUnreadOnly(refVal_unreadOnly);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("countType")))
    {
        utility::string_t refVal_countType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("countType")), refVal_countType );
        setCountType(refVal_countType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("matches")))
    {
        std::vector<std::shared_ptr<SmsMatchOption>> refVal_matches;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("matches")), refVal_matches );
        setMatches(refVal_matches);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("sortDirection")))
    {
        utility::string_t refVal_sortDirection;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("sortDirection")), refVal_sortDirection );
        setSortDirection(refVal_sortDirection);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("since")))
    {
        utility::datetime refVal_since;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("since")), refVal_since );
        setSince(refVal_since);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("before")))
    {
        utility::datetime refVal_before;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("before")), refVal_before );
        setBefore(refVal_before);
    }
    return ok;
}

utility::string_t WaitForSmsConditions::getPhoneNumberId() const
{
    return m_PhoneNumberId;
}

void WaitForSmsConditions::setPhoneNumberId(const utility::string_t& value)
{
    m_PhoneNumberId = value;
    m_PhoneNumberIdIsSet = true;
}

bool WaitForSmsConditions::phoneNumberIdIsSet() const
{
    return m_PhoneNumberIdIsSet;
}

void WaitForSmsConditions::unsetPhoneNumberId()
{
    m_PhoneNumberIdIsSet = false;
}
int32_t WaitForSmsConditions::getLimit() const
{
    return m_Limit;
}

void WaitForSmsConditions::setLimit(int32_t value)
{
    m_Limit = value;
    m_LimitIsSet = true;
}

bool WaitForSmsConditions::limitIsSet() const
{
    return m_LimitIsSet;
}

void WaitForSmsConditions::unsetLimit()
{
    m_LimitIsSet = false;
}
int64_t WaitForSmsConditions::getCount() const
{
    return m_Count;
}

void WaitForSmsConditions::setCount(int64_t value)
{
    m_Count = value;
    m_CountIsSet = true;
}

bool WaitForSmsConditions::countIsSet() const
{
    return m_CountIsSet;
}

void WaitForSmsConditions::unsetCount()
{
    m_CountIsSet = false;
}
int64_t WaitForSmsConditions::getDelayTimeout() const
{
    return m_DelayTimeout;
}

void WaitForSmsConditions::setDelayTimeout(int64_t value)
{
    m_DelayTimeout = value;
    m_DelayTimeoutIsSet = true;
}

bool WaitForSmsConditions::delayTimeoutIsSet() const
{
    return m_DelayTimeoutIsSet;
}

void WaitForSmsConditions::unsetDelayTimeout()
{
    m_DelayTimeoutIsSet = false;
}
int64_t WaitForSmsConditions::getTimeout() const
{
    return m_Timeout;
}

void WaitForSmsConditions::setTimeout(int64_t value)
{
    m_Timeout = value;
    m_TimeoutIsSet = true;
}

bool WaitForSmsConditions::timeoutIsSet() const
{
    return m_TimeoutIsSet;
}

void WaitForSmsConditions::unsetTimeout()
{
    m_TimeoutIsSet = false;
}
bool WaitForSmsConditions::isUnreadOnly() const
{
    return m_UnreadOnly;
}

void WaitForSmsConditions::setUnreadOnly(bool value)
{
    m_UnreadOnly = value;
    m_UnreadOnlyIsSet = true;
}

bool WaitForSmsConditions::unreadOnlyIsSet() const
{
    return m_UnreadOnlyIsSet;
}

void WaitForSmsConditions::unsetUnreadOnly()
{
    m_UnreadOnlyIsSet = false;
}
utility::string_t WaitForSmsConditions::getCountType() const
{
    return m_CountType;
}

void WaitForSmsConditions::setCountType(const utility::string_t& value)
{
    m_CountType = value;
    m_CountTypeIsSet = true;
}

bool WaitForSmsConditions::countTypeIsSet() const
{
    return m_CountTypeIsSet;
}

void WaitForSmsConditions::unsetCountType()
{
    m_CountTypeIsSet = false;
}
std::vector<std::shared_ptr<SmsMatchOption>>& WaitForSmsConditions::getMatches()
{
    return m_Matches;
}

void WaitForSmsConditions::setMatches(const std::vector<std::shared_ptr<SmsMatchOption>>& value)
{
    m_Matches = value;
    m_MatchesIsSet = true;
}

bool WaitForSmsConditions::matchesIsSet() const
{
    return m_MatchesIsSet;
}

void WaitForSmsConditions::unsetMatches()
{
    m_MatchesIsSet = false;
}
utility::string_t WaitForSmsConditions::getSortDirection() const
{
    return m_SortDirection;
}

void WaitForSmsConditions::setSortDirection(const utility::string_t& value)
{
    m_SortDirection = value;
    m_SortDirectionIsSet = true;
}

bool WaitForSmsConditions::sortDirectionIsSet() const
{
    return m_SortDirectionIsSet;
}

void WaitForSmsConditions::unsetSortDirection()
{
    m_SortDirectionIsSet = false;
}
utility::datetime WaitForSmsConditions::getSince() const
{
    return m_Since;
}

void WaitForSmsConditions::setSince(const utility::datetime& value)
{
    m_Since = value;
    m_SinceIsSet = true;
}

bool WaitForSmsConditions::sinceIsSet() const
{
    return m_SinceIsSet;
}

void WaitForSmsConditions::unsetSince()
{
    m_SinceIsSet = false;
}
utility::datetime WaitForSmsConditions::getBefore() const
{
    return m_Before;
}

void WaitForSmsConditions::setBefore(const utility::datetime& value)
{
    m_Before = value;
    m_BeforeIsSet = true;
}

bool WaitForSmsConditions::beforeIsSet() const
{
    return m_BeforeIsSet;
}

void WaitForSmsConditions::unsetBefore()
{
    m_BeforeIsSet = false;
}
}
}
}
}


