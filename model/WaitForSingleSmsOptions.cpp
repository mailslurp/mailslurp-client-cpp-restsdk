/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.1.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "WaitForSingleSmsOptions.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {




WaitForSingleSmsOptions::WaitForSingleSmsOptions()
{
    m_PhoneNumberId = utility::conversions::to_string_t("");
    m_PhoneNumberIdIsSet = false;
    m_Timeout = 0L;
    m_TimeoutIsSet = false;
    m_UnreadOnly = false;
    m_UnreadOnlyIsSet = false;
    m_Before = utility::datetime();
    m_BeforeIsSet = false;
    m_Since = utility::datetime();
    m_SinceIsSet = false;
    m_SortDirection = utility::conversions::to_string_t("");
    m_SortDirectionIsSet = false;
    m_Delay = 0L;
    m_DelayIsSet = false;
}

WaitForSingleSmsOptions::~WaitForSingleSmsOptions()
{
}

void WaitForSingleSmsOptions::validate()
{
    // TODO: implement validation
}

web::json::value WaitForSingleSmsOptions::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_PhoneNumberIdIsSet)
    {
        val[utility::conversions::to_string_t("phoneNumberId")] = ModelBase::toJson(m_PhoneNumberId);
    }
    if(m_TimeoutIsSet)
    {
        val[utility::conversions::to_string_t("timeout")] = ModelBase::toJson(m_Timeout);
    }
    if(m_UnreadOnlyIsSet)
    {
        val[utility::conversions::to_string_t("unreadOnly")] = ModelBase::toJson(m_UnreadOnly);
    }
    if(m_BeforeIsSet)
    {
        val[utility::conversions::to_string_t("before")] = ModelBase::toJson(m_Before);
    }
    if(m_SinceIsSet)
    {
        val[utility::conversions::to_string_t("since")] = ModelBase::toJson(m_Since);
    }
    if(m_SortDirectionIsSet)
    {
        val[utility::conversions::to_string_t("sortDirection")] = ModelBase::toJson(m_SortDirection);
    }
    if(m_DelayIsSet)
    {
        val[utility::conversions::to_string_t("delay")] = ModelBase::toJson(m_Delay);
    }

    return val;
}

bool WaitForSingleSmsOptions::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t("phoneNumberId")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("phoneNumberId"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_phoneNumberId;
            ok &= ModelBase::fromJson(fieldValue, refVal_phoneNumberId);
            setPhoneNumberId(refVal_phoneNumberId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("timeout")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("timeout"));
        if(!fieldValue.is_null())
        {
            int64_t refVal_timeout;
            ok &= ModelBase::fromJson(fieldValue, refVal_timeout);
            setTimeout(refVal_timeout);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("unreadOnly")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("unreadOnly"));
        if(!fieldValue.is_null())
        {
            bool refVal_unreadOnly;
            ok &= ModelBase::fromJson(fieldValue, refVal_unreadOnly);
            setUnreadOnly(refVal_unreadOnly);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("before")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("before"));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_before;
            ok &= ModelBase::fromJson(fieldValue, refVal_before);
            setBefore(refVal_before);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("since")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("since"));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_since;
            ok &= ModelBase::fromJson(fieldValue, refVal_since);
            setSince(refVal_since);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("sortDirection")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("sortDirection"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_sortDirection;
            ok &= ModelBase::fromJson(fieldValue, refVal_sortDirection);
            setSortDirection(refVal_sortDirection);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("delay")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("delay"));
        if(!fieldValue.is_null())
        {
            int64_t refVal_delay;
            ok &= ModelBase::fromJson(fieldValue, refVal_delay);
            setDelay(refVal_delay);
        }
    }
    return ok;
}

void WaitForSingleSmsOptions::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_PhoneNumberIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("phoneNumberId"), m_PhoneNumberId));
    }
    if(m_TimeoutIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("timeout"), m_Timeout));
    }
    if(m_UnreadOnlyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("unreadOnly"), m_UnreadOnly));
    }
    if(m_BeforeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("before"), m_Before));
    }
    if(m_SinceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("since"), m_Since));
    }
    if(m_SortDirectionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("sortDirection"), m_SortDirection));
    }
    if(m_DelayIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("delay"), m_Delay));
    }
}

bool WaitForSingleSmsOptions::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("phoneNumberId")))
    {
        utility::string_t refVal_phoneNumberId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("phoneNumberId")), refVal_phoneNumberId );
        setPhoneNumberId(refVal_phoneNumberId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("timeout")))
    {
        int64_t refVal_timeout;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("timeout")), refVal_timeout );
        setTimeout(refVal_timeout);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("unreadOnly")))
    {
        bool refVal_unreadOnly;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("unreadOnly")), refVal_unreadOnly );
        setUnreadOnly(refVal_unreadOnly);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("before")))
    {
        utility::datetime refVal_before;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("before")), refVal_before );
        setBefore(refVal_before);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("since")))
    {
        utility::datetime refVal_since;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("since")), refVal_since );
        setSince(refVal_since);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("sortDirection")))
    {
        utility::string_t refVal_sortDirection;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("sortDirection")), refVal_sortDirection );
        setSortDirection(refVal_sortDirection);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("delay")))
    {
        int64_t refVal_delay;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("delay")), refVal_delay );
        setDelay(refVal_delay);
    }
    return ok;
}

utility::string_t WaitForSingleSmsOptions::getPhoneNumberId() const
{
    return m_PhoneNumberId;
}

void WaitForSingleSmsOptions::setPhoneNumberId(const utility::string_t& value)
{
    m_PhoneNumberId = value;
    m_PhoneNumberIdIsSet = true;
}

bool WaitForSingleSmsOptions::phoneNumberIdIsSet() const
{
    return m_PhoneNumberIdIsSet;
}

void WaitForSingleSmsOptions::unsetPhoneNumberId()
{
    m_PhoneNumberIdIsSet = false;
}
int64_t WaitForSingleSmsOptions::getTimeout() const
{
    return m_Timeout;
}

void WaitForSingleSmsOptions::setTimeout(int64_t value)
{
    m_Timeout = value;
    m_TimeoutIsSet = true;
}

bool WaitForSingleSmsOptions::timeoutIsSet() const
{
    return m_TimeoutIsSet;
}

void WaitForSingleSmsOptions::unsetTimeout()
{
    m_TimeoutIsSet = false;
}
bool WaitForSingleSmsOptions::isUnreadOnly() const
{
    return m_UnreadOnly;
}

void WaitForSingleSmsOptions::setUnreadOnly(bool value)
{
    m_UnreadOnly = value;
    m_UnreadOnlyIsSet = true;
}

bool WaitForSingleSmsOptions::unreadOnlyIsSet() const
{
    return m_UnreadOnlyIsSet;
}

void WaitForSingleSmsOptions::unsetUnreadOnly()
{
    m_UnreadOnlyIsSet = false;
}
utility::datetime WaitForSingleSmsOptions::getBefore() const
{
    return m_Before;
}

void WaitForSingleSmsOptions::setBefore(const utility::datetime& value)
{
    m_Before = value;
    m_BeforeIsSet = true;
}

bool WaitForSingleSmsOptions::beforeIsSet() const
{
    return m_BeforeIsSet;
}

void WaitForSingleSmsOptions::unsetBefore()
{
    m_BeforeIsSet = false;
}
utility::datetime WaitForSingleSmsOptions::getSince() const
{
    return m_Since;
}

void WaitForSingleSmsOptions::setSince(const utility::datetime& value)
{
    m_Since = value;
    m_SinceIsSet = true;
}

bool WaitForSingleSmsOptions::sinceIsSet() const
{
    return m_SinceIsSet;
}

void WaitForSingleSmsOptions::unsetSince()
{
    m_SinceIsSet = false;
}
utility::string_t WaitForSingleSmsOptions::getSortDirection() const
{
    return m_SortDirection;
}

void WaitForSingleSmsOptions::setSortDirection(const utility::string_t& value)
{
    m_SortDirection = value;
    m_SortDirectionIsSet = true;
}

bool WaitForSingleSmsOptions::sortDirectionIsSet() const
{
    return m_SortDirectionIsSet;
}

void WaitForSingleSmsOptions::unsetSortDirection()
{
    m_SortDirectionIsSet = false;
}
int64_t WaitForSingleSmsOptions::getDelay() const
{
    return m_Delay;
}

void WaitForSingleSmsOptions::setDelay(int64_t value)
{
    m_Delay = value;
    m_DelayIsSet = true;
}

bool WaitForSingleSmsOptions::delayIsSet() const
{
    return m_DelayIsSet;
}

void WaitForSingleSmsOptions::unsetDelay()
{
    m_DelayIsSet = false;
}
}
}
}
}


