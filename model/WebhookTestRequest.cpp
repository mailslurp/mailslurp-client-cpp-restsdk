/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.   ## Resources - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository 
 *
 * The version of the OpenAPI document: 6.5.2
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "WebhookTestRequest.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {




WebhookTestRequest::WebhookTestRequest()
{
    m_HeadersIsSet = false;
    m_Method = utility::conversions::to_string_t("");
    m_MethodIsSet = false;
    m_Payload = utility::conversions::to_string_t("");
    m_PayloadIsSet = false;
    m_Url = utility::conversions::to_string_t("");
    m_UrlIsSet = false;
}

WebhookTestRequest::~WebhookTestRequest()
{
}

void WebhookTestRequest::validate()
{
    // TODO: implement validation
}

web::json::value WebhookTestRequest::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_HeadersIsSet)
    {
        val[utility::conversions::to_string_t("headers")] = ModelBase::toJson(m_Headers);
    }
    if(m_MethodIsSet)
    {
        val[utility::conversions::to_string_t("method")] = ModelBase::toJson(m_Method);
    }
    if(m_PayloadIsSet)
    {
        val[utility::conversions::to_string_t("payload")] = ModelBase::toJson(m_Payload);
    }
    if(m_UrlIsSet)
    {
        val[utility::conversions::to_string_t("url")] = ModelBase::toJson(m_Url);
    }

    return val;
}

bool WebhookTestRequest::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t("headers")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("headers"));
        if(!fieldValue.is_null())
        {
            std::map<utility::string_t, utility::string_t> refVal_headers;
            ok &= ModelBase::fromJson(fieldValue, refVal_headers);
            setHeaders(refVal_headers);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("method")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("method"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_method;
            ok &= ModelBase::fromJson(fieldValue, refVal_method);
            setMethod(refVal_method);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("payload")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("payload"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_payload;
            ok &= ModelBase::fromJson(fieldValue, refVal_payload);
            setPayload(refVal_payload);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("url")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("url"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_url;
            ok &= ModelBase::fromJson(fieldValue, refVal_url);
            setUrl(refVal_url);
        }
    }
    return ok;
}

void WebhookTestRequest::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_HeadersIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("headers"), m_Headers));
    }
    if(m_MethodIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("method"), m_Method));
    }
    if(m_PayloadIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("payload"), m_Payload));
    }
    if(m_UrlIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("url"), m_Url));
    }
}

bool WebhookTestRequest::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("headers")))
    {
        std::map<utility::string_t, utility::string_t> refVal_headers;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("headers")), refVal_headers );
        setHeaders(refVal_headers);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("method")))
    {
        utility::string_t refVal_method;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("method")), refVal_method );
        setMethod(refVal_method);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("payload")))
    {
        utility::string_t refVal_payload;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("payload")), refVal_payload );
        setPayload(refVal_payload);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("url")))
    {
        utility::string_t refVal_url;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("url")), refVal_url );
        setUrl(refVal_url);
    }
    return ok;
}

std::map<utility::string_t, utility::string_t>& WebhookTestRequest::getHeaders()
{
    return m_Headers;
}

void WebhookTestRequest::setHeaders(const std::map<utility::string_t, utility::string_t>& value)
{
    m_Headers = value;
    m_HeadersIsSet = true;
}

bool WebhookTestRequest::headersIsSet() const
{
    return m_HeadersIsSet;
}

void WebhookTestRequest::unsetHeaders()
{
    m_HeadersIsSet = false;
}
utility::string_t WebhookTestRequest::getMethod() const
{
    return m_Method;
}

void WebhookTestRequest::setMethod(const utility::string_t& value)
{
    m_Method = value;
    m_MethodIsSet = true;
}

bool WebhookTestRequest::methodIsSet() const
{
    return m_MethodIsSet;
}

void WebhookTestRequest::unsetMethod()
{
    m_MethodIsSet = false;
}
utility::string_t WebhookTestRequest::getPayload() const
{
    return m_Payload;
}

void WebhookTestRequest::setPayload(const utility::string_t& value)
{
    m_Payload = value;
    m_PayloadIsSet = true;
}

bool WebhookTestRequest::payloadIsSet() const
{
    return m_PayloadIsSet;
}

void WebhookTestRequest::unsetPayload()
{
    m_PayloadIsSet = false;
}
utility::string_t WebhookTestRequest::getUrl() const
{
    return m_Url;
}

void WebhookTestRequest::setUrl(const utility::string_t& value)
{
    m_Url = value;
    m_UrlIsSet = true;
}

bool WebhookTestRequest::urlIsSet() const
{
    return m_UrlIsSet;
}

void WebhookTestRequest::unsetUrl()
{
    m_UrlIsSet = false;
}
}
}
}
}


