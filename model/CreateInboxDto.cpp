/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository 
 *
 * The version of the OpenAPI document: 6.5.2
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 4.3.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CreateInboxDto.h"

namespace com {
namespace mailslurp {
namespace client {
namespace model {




CreateInboxDto::CreateInboxDto()
{
    m_AllowTeamAccess = false;
    m_AllowTeamAccessIsSet = false;
    m_Description = utility::conversions::to_string_t("");
    m_DescriptionIsSet = false;
    m_EmailAddress = utility::conversions::to_string_t("");
    m_EmailAddressIsSet = false;
    m_ExpiresAt = utility::datetime();
    m_ExpiresAtIsSet = false;
    m_ExpiresIn = 0L;
    m_ExpiresInIsSet = false;
    m_Favourite = false;
    m_FavouriteIsSet = false;
    m_InboxType = utility::conversions::to_string_t("");
    m_InboxTypeIsSet = false;
    m_Name = utility::conversions::to_string_t("");
    m_NameIsSet = false;
    m_TagsIsSet = false;
    m_UseDomainPool = false;
    m_UseDomainPoolIsSet = false;
}

CreateInboxDto::~CreateInboxDto()
{
}

void CreateInboxDto::validate()
{
    // TODO: implement validation
}

web::json::value CreateInboxDto::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_AllowTeamAccessIsSet)
    {
        val[utility::conversions::to_string_t("allowTeamAccess")] = ModelBase::toJson(m_AllowTeamAccess);
    }
    if(m_DescriptionIsSet)
    {
        val[utility::conversions::to_string_t("description")] = ModelBase::toJson(m_Description);
    }
    if(m_EmailAddressIsSet)
    {
        val[utility::conversions::to_string_t("emailAddress")] = ModelBase::toJson(m_EmailAddress);
    }
    if(m_ExpiresAtIsSet)
    {
        val[utility::conversions::to_string_t("expiresAt")] = ModelBase::toJson(m_ExpiresAt);
    }
    if(m_ExpiresInIsSet)
    {
        val[utility::conversions::to_string_t("expiresIn")] = ModelBase::toJson(m_ExpiresIn);
    }
    if(m_FavouriteIsSet)
    {
        val[utility::conversions::to_string_t("favourite")] = ModelBase::toJson(m_Favourite);
    }
    if(m_InboxTypeIsSet)
    {
        val[utility::conversions::to_string_t("inboxType")] = ModelBase::toJson(m_InboxType);
    }
    if(m_NameIsSet)
    {
        val[utility::conversions::to_string_t("name")] = ModelBase::toJson(m_Name);
    }
    if(m_TagsIsSet)
    {
        val[utility::conversions::to_string_t("tags")] = ModelBase::toJson(m_Tags);
    }
    if(m_UseDomainPoolIsSet)
    {
        val[utility::conversions::to_string_t("useDomainPool")] = ModelBase::toJson(m_UseDomainPool);
    }

    return val;
}

bool CreateInboxDto::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t("allowTeamAccess")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("allowTeamAccess"));
        if(!fieldValue.is_null())
        {
            bool refVal_allowTeamAccess;
            ok &= ModelBase::fromJson(fieldValue, refVal_allowTeamAccess);
            setAllowTeamAccess(refVal_allowTeamAccess);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("description")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("description"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_description;
            ok &= ModelBase::fromJson(fieldValue, refVal_description);
            setDescription(refVal_description);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("emailAddress")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("emailAddress"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_emailAddress;
            ok &= ModelBase::fromJson(fieldValue, refVal_emailAddress);
            setEmailAddress(refVal_emailAddress);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("expiresAt")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("expiresAt"));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_expiresAt;
            ok &= ModelBase::fromJson(fieldValue, refVal_expiresAt);
            setExpiresAt(refVal_expiresAt);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("expiresIn")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("expiresIn"));
        if(!fieldValue.is_null())
        {
            int64_t refVal_expiresIn;
            ok &= ModelBase::fromJson(fieldValue, refVal_expiresIn);
            setExpiresIn(refVal_expiresIn);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("favourite")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("favourite"));
        if(!fieldValue.is_null())
        {
            bool refVal_favourite;
            ok &= ModelBase::fromJson(fieldValue, refVal_favourite);
            setFavourite(refVal_favourite);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("inboxType")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("inboxType"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_inboxType;
            ok &= ModelBase::fromJson(fieldValue, refVal_inboxType);
            setInboxType(refVal_inboxType);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("name")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("name"));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_name;
            ok &= ModelBase::fromJson(fieldValue, refVal_name);
            setName(refVal_name);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("tags")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("tags"));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_tags;
            ok &= ModelBase::fromJson(fieldValue, refVal_tags);
            setTags(refVal_tags);
        }
    }
    if(val.has_field(utility::conversions::to_string_t("useDomainPool")))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t("useDomainPool"));
        if(!fieldValue.is_null())
        {
            bool refVal_useDomainPool;
            ok &= ModelBase::fromJson(fieldValue, refVal_useDomainPool);
            setUseDomainPool(refVal_useDomainPool);
        }
    }
    return ok;
}

void CreateInboxDto::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }
    if(m_AllowTeamAccessIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("allowTeamAccess"), m_AllowTeamAccess));
    }
    if(m_DescriptionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("description"), m_Description));
    }
    if(m_EmailAddressIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("emailAddress"), m_EmailAddress));
    }
    if(m_ExpiresAtIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("expiresAt"), m_ExpiresAt));
    }
    if(m_ExpiresInIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("expiresIn"), m_ExpiresIn));
    }
    if(m_FavouriteIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("favourite"), m_Favourite));
    }
    if(m_InboxTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("inboxType"), m_InboxType));
    }
    if(m_NameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("name"), m_Name));
    }
    if(m_TagsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("tags"), m_Tags));
    }
    if(m_UseDomainPoolIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("useDomainPool"), m_UseDomainPool));
    }
}

bool CreateInboxDto::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("allowTeamAccess")))
    {
        bool refVal_allowTeamAccess;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("allowTeamAccess")), refVal_allowTeamAccess );
        setAllowTeamAccess(refVal_allowTeamAccess);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("description")))
    {
        utility::string_t refVal_description;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("description")), refVal_description );
        setDescription(refVal_description);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("emailAddress")))
    {
        utility::string_t refVal_emailAddress;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("emailAddress")), refVal_emailAddress );
        setEmailAddress(refVal_emailAddress);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("expiresAt")))
    {
        utility::datetime refVal_expiresAt;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("expiresAt")), refVal_expiresAt );
        setExpiresAt(refVal_expiresAt);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("expiresIn")))
    {
        int64_t refVal_expiresIn;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("expiresIn")), refVal_expiresIn );
        setExpiresIn(refVal_expiresIn);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("favourite")))
    {
        bool refVal_favourite;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("favourite")), refVal_favourite );
        setFavourite(refVal_favourite);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("inboxType")))
    {
        utility::string_t refVal_inboxType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("inboxType")), refVal_inboxType );
        setInboxType(refVal_inboxType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("name")))
    {
        utility::string_t refVal_name;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("name")), refVal_name );
        setName(refVal_name);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("tags")))
    {
        std::vector<utility::string_t> refVal_tags;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("tags")), refVal_tags );
        setTags(refVal_tags);
    }
    if(multipart->hasContent(utility::conversions::to_string_t("useDomainPool")))
    {
        bool refVal_useDomainPool;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t("useDomainPool")), refVal_useDomainPool );
        setUseDomainPool(refVal_useDomainPool);
    }
    return ok;
}

bool CreateInboxDto::isAllowTeamAccess() const
{
    return m_AllowTeamAccess;
}

void CreateInboxDto::setAllowTeamAccess(bool value)
{
    m_AllowTeamAccess = value;
    m_AllowTeamAccessIsSet = true;
}

bool CreateInboxDto::allowTeamAccessIsSet() const
{
    return m_AllowTeamAccessIsSet;
}

void CreateInboxDto::unsetAllowTeamAccess()
{
    m_AllowTeamAccessIsSet = false;
}
utility::string_t CreateInboxDto::getDescription() const
{
    return m_Description;
}

void CreateInboxDto::setDescription(const utility::string_t& value)
{
    m_Description = value;
    m_DescriptionIsSet = true;
}

bool CreateInboxDto::descriptionIsSet() const
{
    return m_DescriptionIsSet;
}

void CreateInboxDto::unsetDescription()
{
    m_DescriptionIsSet = false;
}
utility::string_t CreateInboxDto::getEmailAddress() const
{
    return m_EmailAddress;
}

void CreateInboxDto::setEmailAddress(const utility::string_t& value)
{
    m_EmailAddress = value;
    m_EmailAddressIsSet = true;
}

bool CreateInboxDto::emailAddressIsSet() const
{
    return m_EmailAddressIsSet;
}

void CreateInboxDto::unsetEmailAddress()
{
    m_EmailAddressIsSet = false;
}
utility::datetime CreateInboxDto::getExpiresAt() const
{
    return m_ExpiresAt;
}

void CreateInboxDto::setExpiresAt(const utility::datetime& value)
{
    m_ExpiresAt = value;
    m_ExpiresAtIsSet = true;
}

bool CreateInboxDto::expiresAtIsSet() const
{
    return m_ExpiresAtIsSet;
}

void CreateInboxDto::unsetExpiresAt()
{
    m_ExpiresAtIsSet = false;
}
int64_t CreateInboxDto::getExpiresIn() const
{
    return m_ExpiresIn;
}

void CreateInboxDto::setExpiresIn(int64_t value)
{
    m_ExpiresIn = value;
    m_ExpiresInIsSet = true;
}

bool CreateInboxDto::expiresInIsSet() const
{
    return m_ExpiresInIsSet;
}

void CreateInboxDto::unsetExpiresIn()
{
    m_ExpiresInIsSet = false;
}
bool CreateInboxDto::isFavourite() const
{
    return m_Favourite;
}

void CreateInboxDto::setFavourite(bool value)
{
    m_Favourite = value;
    m_FavouriteIsSet = true;
}

bool CreateInboxDto::favouriteIsSet() const
{
    return m_FavouriteIsSet;
}

void CreateInboxDto::unsetFavourite()
{
    m_FavouriteIsSet = false;
}
utility::string_t CreateInboxDto::getInboxType() const
{
    return m_InboxType;
}

void CreateInboxDto::setInboxType(const utility::string_t& value)
{
    m_InboxType = value;
    m_InboxTypeIsSet = true;
}

bool CreateInboxDto::inboxTypeIsSet() const
{
    return m_InboxTypeIsSet;
}

void CreateInboxDto::unsetInboxType()
{
    m_InboxTypeIsSet = false;
}
utility::string_t CreateInboxDto::getName() const
{
    return m_Name;
}

void CreateInboxDto::setName(const utility::string_t& value)
{
    m_Name = value;
    m_NameIsSet = true;
}

bool CreateInboxDto::nameIsSet() const
{
    return m_NameIsSet;
}

void CreateInboxDto::unsetName()
{
    m_NameIsSet = false;
}
std::vector<utility::string_t>& CreateInboxDto::getTags()
{
    return m_Tags;
}

void CreateInboxDto::setTags(const std::vector<utility::string_t>& value)
{
    m_Tags = value;
    m_TagsIsSet = true;
}

bool CreateInboxDto::tagsIsSet() const
{
    return m_TagsIsSet;
}

void CreateInboxDto::unsetTags()
{
    m_TagsIsSet = false;
}
bool CreateInboxDto::isUseDomainPool() const
{
    return m_UseDomainPool;
}

void CreateInboxDto::setUseDomainPool(bool value)
{
    m_UseDomainPool = value;
    m_UseDomainPoolIsSet = true;
}

bool CreateInboxDto::useDomainPoolIsSet() const
{
    return m_UseDomainPoolIsSet;
}

void CreateInboxDto::unsetUseDomainPool()
{
    m_UseDomainPoolIsSet = false;
}
}
}
}
}


