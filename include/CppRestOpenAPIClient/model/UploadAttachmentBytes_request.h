/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * UploadAttachmentBytes_request.h
 *
 * Byte array request body
 */

#ifndef COM_MAILSLURP_CLIENT_MODEL_UploadAttachmentBytes_request_H_
#define COM_MAILSLURP_CLIENT_MODEL_UploadAttachmentBytes_request_H_


#include "CppRestOpenAPIClient/ModelBase.h"

#include <cpprest/details/basic_types.h>

namespace com {
namespace mailslurp {
namespace client {
namespace model {


/// <summary>
/// Byte array request body
/// </summary>
class  UploadAttachmentBytes_request
    : public ModelBase
{
public:
    UploadAttachmentBytes_request();
    virtual ~UploadAttachmentBytes_request();

    /////////////////////////////////////////////
    /// ModelBase overrides

    void validate() override;

    web::json::value toJson() const override;
    bool fromJson(const web::json::value& json) override;

    void toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) const override;
    bool fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) override;

    /////////////////////////////////////////////
    /// UploadAttachmentBytes_request members

    /// <summary>
    /// 
    /// </summary>
    int32_t getShort() const;
    bool r_shortIsSet() const;
    void unsetshort();

    void setShort(int32_t value);

    /// <summary>
    /// 
    /// </summary>
    utility::string_t getChar() const;
    bool r_charIsSet() const;
    void unsetchar();

    void setChar(const utility::string_t& value);

    /// <summary>
    /// 
    /// </summary>
    int32_t getInt() const;
    bool r_intIsSet() const;
    void unsetint();

    void setInt(int32_t value);

    /// <summary>
    /// 
    /// </summary>
    int64_t getLong() const;
    bool r_longIsSet() const;
    void unsetlong();

    void setLong(int64_t value);

    /// <summary>
    /// 
    /// </summary>
    float getFloat() const;
    bool r_floatIsSet() const;
    void unsetfloat();

    void setFloat(float value);

    /// <summary>
    /// 
    /// </summary>
    double getDouble() const;
    bool r_doubleIsSet() const;
    void unsetdouble();

    void setDouble(double value);

    /// <summary>
    /// 
    /// </summary>
    bool isDirect() const;
    bool directIsSet() const;
    void unsetDirect();

    void setDirect(bool value);

    /// <summary>
    /// 
    /// </summary>
    bool isReadOnly() const;
    bool readOnlyIsSet() const;
    void unsetReadOnly();

    void setReadOnly(bool value);


protected:
    int32_t m_short;
    bool m_shortIsSet;
    utility::string_t m_char;
    bool m_charIsSet;
    int32_t m_int;
    bool m_intIsSet;
    int64_t m_long;
    bool m_longIsSet;
    float m_float;
    bool m_floatIsSet;
    double m_double;
    bool m_doubleIsSet;
    bool m_Direct;
    bool m_DirectIsSet;
    bool m_ReadOnly;
    bool m_ReadOnlyIsSet;
};


}
}
}
}

#endif /* COM_MAILSLURP_CLIENT_MODEL_UploadAttachmentBytes_request_H_ */
